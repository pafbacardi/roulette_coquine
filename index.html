<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu Coquin</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <!-- Tone.js CDN pour les sons (supprim√©) -->

    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Styles pour l'animation de rebond */
        .reel-item-container {
            height: 80px; /* Hauteur fixe pour chaque √©l√©ment du rouleau */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Cache le contenu qui d√©passe */
        }

        .reel-content-wrapper {
            transition: transform 0.1s linear; /* Pour un d√©filement rapide continu */
        }

        /* Classe pour l'animation de rotation type machine √† sous */
        .spinning .reel-content-wrapper {
            animation: spinReel 0.1s linear infinite;
        }

        @keyframes spinReel {
            0% { transform: translateY(0); }
            100% { transform: translateY(-100%); } /* Ajuster en fonction de la hauteur du contenu */
        }

        /* Styles pour les modals */
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100; /* Increased z-index to ensure it's on top */
        }
        .modal-content {
            transform: scale(1);
            transition: all 0.3s ease-in-out;
        }
        /* Styles pour les sections pliables */
        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background-color: #f3f4f6; /* bg-gray-100 */
            border-radius: 0.5rem; /* rounded-lg */
            margin-bottom: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .collapsible-header:hover {
            background-color: #e5e7eb; /* bg-gray-200 */
        }
        .collapsible-header svg {
            transition: transform 0.2s ease-in-out;
        }
        details[open] .collapsible-header svg {
            transform: rotate(90deg);
        }
        .collapsible-content {
            padding: 0.5rem 1rem 1rem 1rem;
            border-left: 2px solid #a78bfa; /* border-purple-400 */
            margin-left: 0.5rem;
        }
        .nested-collapsible-content {
            border-left: 1px solid #c4b5fd; /* border-purple-300 */
            margin-left: 0.75rem;
            padding-left: 0.75rem;
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-100 via-blue-200 to-purple-200 flex flex-col items-center justify-center p-4 text-gray-800 pb-16 transition-all duration-1000 ease-in-out">

    <!-- Modals (cach√©s par d√©faut) -->
    <div id="instructionsModal" class="fixed inset-0 modal-overlay flex items-center justify-center p-4 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 md:p-8 max-w-md w-full text-center modal-content">
            <h2 class="text-2xl font-bold text-purple-700 mb-4">Bienvenue au Jeu Coquin !</h2>
            <p class="mb-4 text-gray-700">
                Pr√©pare-toi pour une exp√©rience amusante !
                <br /><br />
                **Comment jouer :**
                <br />
                1.  Ajoute entre **2 et 10 joueurs**, en pr√©cisant leur sexe et leurs pr√©f√©rences.
                2.  Le jeu progresse √† travers **6 niveaux d'intensit√©** automatiquement, visualis√©s par une barre de tension.
                3.  Lance la roue pour d√©couvrir une combinaison coquine et un temps !
                <br /><br />
                Amuse-toi bien ! üòâ
            </p>
            <button id="closeInstructions" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105">
                Commen√ßons !
            </button>
        </div>
    </div>

    <div id="errorModal" class="fixed inset-0 modal-overlay flex items-center justify-center p-4 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 md:p-8 max-w-md w-full text-center modal-content">
            <h2 id="errorMessageTitle" class="text-2xl font-bold text-red-600 mb-4">Erreur !</h2>
            <p id="errorMessageText" class="mb-6 text-gray-700"></p>
            <button id="closeErrorModal" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105">
                Compris
            </button>
        </div>
    </div>

    <div id="levelUpModal" class="fixed inset-0 modal-overlay flex items-center justify-center p-4 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 md:p-8 max-w-md w-full text-center modal-content">
            <div class="max-h-[70vh] overflow-y-auto pr-2">
                <h2 id="levelUpTitle" class="text-2xl font-bold text-green-600 mb-4"></h2>
                <p id="levelUpMessage" class="mb-6 text-gray-700"></p>
            </div>
            <button id="closeLevelUpModal" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105 mt-4">
                Continuer le jeu !
            </button>
        </div>
    </div>

    <div id="adminModal" class="fixed inset-0 modal-overlay flex items-center justify-center z-50 p-4 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 md:p-8 max-w-4xl w-full text-center modal-content overflow-y-auto max-h-[90vh]">
            <h2 class="text-3xl font-bold text-purple-700 mb-6">Mode Administrateur</h2>

            <!-- Authentification Admin -->
            <div id="adminAuthSection" class="mb-6">
                <h3 class="text-xl font-bold text-gray-700 mb-3">Acc√®s Admin</h3>
                <input
                    type="password"
                    id="adminPasswordInput"
                    placeholder="Mot de passe Admin"
                    class="p-3 border border-gray-300 rounded-lg w-full max-w-xs focus:ring-2 focus:ring-purple-500 outline-none"
                />
                <button id="validateAdminPassword" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-full shadow-lg mt-4 transition duration-300 ease-in-out">
                    Valider
                </button>
            </div>

            <div id="adminContent" class="space-y-8 mt-8 text-left hidden">
                <!-- √âdition des Actions -->
                <details id="adminActionsDetails" class="mb-6 bg-gray-50 rounded-lg shadow-md">
                    <summary class="collapsible-header text-2xl font-bold text-purple-700">
                        √âditer les Actions
                        <svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                    </summary>
                    <div class="collapsible-content">
                        <div id="actionsEditor" class="space-y-4">
                            <!-- Actions will be rendered here by JS -->
                        </div>
                        <button id="saveActionsData" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-full shadow-lg mt-4 transition duration-300 ease-in-out">
                            Sauvegarder Actions
                        </button>
                    </div>
                </details>

                <!-- √âdition des Zones du Corps -->
                <details id="adminBodyPartsDetails" class="mb-6 bg-gray-50 rounded-lg shadow-md">
                    <summary class="collapsible-header text-2xl font-bold text-purple-700">
                        √âditer les Zones du Corps
                        <svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                    </summary>
                    <div class="collapsible-content">
                        <div id="bodyPartsEditor" class="space-y-4">
                            <!-- Body Parts will be rendered here by JS -->
                        </div>
                        <button id="saveBodyPartsData" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-full shadow-lg mt-4 transition duration-300 ease-in-out">
                            Sauvegarder Zones du Corps
                        </button>
                    </div>
                </details>

                <!-- √âdition des D√©fis Joker -->
                <details id="adminJokerChallengesDetails" class="mb-6 bg-gray-50 rounded-lg shadow-md">
                    <summary class="collapsible-header text-2xl font-bold text-purple-700">
                        √âditer les D√©fis Joker
                        <svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                    </summary>
                    <div class="collapsible-content">
                        <div id="jokerChallengesEditor" class="space-y-4">
                            <!-- Joker Challenges will be rendered here by JS -->
                        </div>
                        <button id="saveJokerChallengesData" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-full shadow-lg mt-4 transition duration-300 ease-in-out">
                            Sauvegarder D√©fis Joker
                        </button>
                    </div>
                </details>
            </div>

            <button id="closeAdminModal" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-full shadow-lg mt-8 transition duration-300 ease-in-out">
                Fermer
            </button>
        </div>
    </div>


    <h1 class="text-4xl md:text-5xl font-extrabold text-white text-center drop-shadow-lg mb-8">
        Jeu Coquin
    </h1>

    <div class="flex flex-col lg:flex-row lg:items-start lg:justify-center w-full max-w-7xl gap-8 p-4">

        <!-- Colonne de gauche : Gestion Joueurs & Barre Tension -->
        <div class="flex flex-col gap-8 w-full lg:w-1/3">
            <!-- Section de gestion des joueurs -->
            <div class="bg-white bg-opacity-80 backdrop-blur-sm rounded-xl shadow-xl p-6 md:p-8 w-full transition-all duration-300 transform hover:scale-105">
                <h2 class="text-2xl font-bold text-purple-700 mb-4 text-center">Gestion des Joueurs</h2>
                <div class="flex flex-col gap-3 mb-4">
                    <input
                        type="text"
                        id="newPlayerName"
                        placeholder="Nom du joueur"
                        class="p-3 border border-purple-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent outline-none transition duration-200"
                    />
                    <div class="flex flex-col sm:flex-row justify-around gap-3 mt-2">
                        <label class="flex items-center cursor-pointer">
                            <input
                                type="radio"
                                name="newPlayerSex"
                                value="homme"
                                checked
                                class="form-radio h-4 w-4 text-purple-600 transition duration-150 ease-in-out"
                            />
                            <span class="ml-2 text-gray-700">Homme</span>
                        </label>
                        <label class="flex items-center cursor-pointer">
                            <input
                                type="radio"
                                name="newPlayerSex"
                                value="femme"
                                class="form-radio h-4 w-4 text-purple-600 transition duration-150 ease-in-out"
                            />
                            <span class="ml-2 text-gray-700">Femme</span>
                        </label>
                    </div>
                    <label class="flex items-center cursor-pointer mt-2">
                        <input
                            type="checkbox"
                            id="newPlayerAcceptSameSex"
                            checked
                            class="form-checkbox h-4 w-4 text-purple-600 rounded transition duration-150 ease-in-out"
                        />
                        <span class="ml-2 text-gray-700">Accepte les actions avec le m√™me sexe</span>
                    </label>
                    <div class="flex flex-col md:flex-row gap-3 mt-4">
                        <button
                            id="addPlayerBtn"
                            class="flex-grow bg-purple-500 hover:bg-purple-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            Ajouter Joueur
                        </button>
                        <button
                            id="addTenPlayersBtn"
                            class="flex-grow bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            Cr√©er 10 Joueurs Auto
                        </button>
                    </div>
                </div>
                <div id="playersList" class="grid grid-cols-1 sm:grid-cols-2 gap-3 mt-4">
                    <!-- Players will be rendered here by JS -->
                </div>
                <p id="playerCountMessage" class="text-sm text-red-600 mt-2 text-center hidden">
                    <!-- Message pour le nombre de joueurs -->
                </p>

                <!-- S√©lecteur de niveau -->
                <div class="mt-6">
                    <label for="level-select" class="block text-lg font-bold text-purple-700 mb-2 text-center">
                        Aller au Niveau :
                    </label>
                    <select
                        id="level-select"
                        class="block w-full p-3 border border-purple-300 rounded-lg bg-white focus:ring-2 focus:ring-purple-500 focus:border-transparent outline-none transition duration-200 text-center text-lg font-semibold"
                    >
                        <!-- Options will be rendered by JS -->
                    </select>
                </div>
            </div>

            <!-- Section de la barre de tension -->
            <div class="bg-white bg-opacity-80 backdrop-blur-sm rounded-xl shadow-xl p-6 md:p-8 w-full flex flex-col items-center transition-all duration-300 transform hover:scale-105">
                <h2 class="text-2xl font-bold text-purple-700 mb-4 text-center">Tension Montante</h2>
                <div class="relative w-20 h-48 bg-gray-200 rounded-full overflow-hidden border-4 border-purple-400 flex items-end justify-center">
                    <!-- La barre de remplissage -->
                    <div
                        id="tensionFill"
                        class="absolute bottom-0 w-full bg-gradient-to-t from-pink-500 to-red-600 transition-all duration-500 ease-in-out"
                        style="height: 0%;"
                    ></div>
                    <!-- La base ou le "point de d√©part" stylis√© -->
                    <div class="absolute w-10 h-10 bg-red-700 rounded-full -bottom-5 border-4 border-purple-400"></div>
                    <!-- La zone "culminante" stylis√©e en haut -->
                    <div class="absolute top-0 w-12 h-10 bg-gradient-to-br from-purple-500 to-pink-500 rounded-full opacity-90 border-4 border-purple-400 flex items-center justify-center">
                        <span class="text-white text-xl font-bold">üíñ</span>
                    </div>
                    <!-- Les marqueurs de niveau -->
                    <div class="absolute top-0 w-full h-full flex flex-col justify-between py-2 text-gray-700 font-semibold text-xs">
                        <span class="text-center">Niveau 6</span>
                        <span class="text-center">Niveau 5</span>
                        <span class="text-center">Niveau 4</span>
                        <span class="text-center">Niveau 3</span>
                        <span class="text-center">Niveau 2</span>
                        <span class="text-center">Niveau 1</span>
                    </div>
                </div>
                <p id="currentLevelName" class="mt-4 text-lg font-semibold text-purple-800">
                    Niveau 1 (Doux)
                </p>
                <p id="currentLevelTypes" class="text-sm text-gray-600 text-center">
                    Actions : <span class="font-semibold text-purple-700">Doux</span> /
                    Zones : <span class="font-semibold text-purple-700">Doux</span>
                </p>
            </div>
        </div>

        <!-- Colonne de droite : Rouleaux & Contr√¥les du Jeu -->
        <div class="bg-white bg-opacity-80 backdrop-blur-sm rounded-xl shadow-xl p-6 md:p-8 w-full lg:w-2/3 text-center transition-all duration-300 transform hover:scale-105">
            <h2 class="text-2xl font-bold text-purple-700 mb-6">Le Tirage Coquin</h2>

            <!-- Nouvelle section pour la phrase de r√©sultat -->
            <div id="resultPhraseDisplay" class="bg-purple-100 p-4 rounded-lg shadow-md mb-6 hidden">
                <p class="text-xl font-semibold text-purple-800" id="resultText">
                    <!-- La phrase de r√©sultat sera affich√©e ici -->
                </p>
                <!-- Nouvelle consigne ajout√©e ici -->
                <p class="text-sm text-gray-600 mt-2">
                    **Consigne :** Tout accessoire ou v√™tement g√™nant doit √™tre retir√©.
                </p>
            </div>

            <!-- Affichage des rouleaux pour les niveaux 1-5 -->
            <div id="gameReels" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-5 gap-4 mb-8">
                <!-- Player 1 Reel -->
                <div id="player1Reel" class="relative bg-purple-50 p-2 rounded-lg shadow-inner border border-purple-200 flex flex-col items-center justify-center min-h-[80px] overflow-hidden reel-item-container cursor-pointer">
                    <div class="reel-content-wrapper">
                        <p class="text-xl font-bold text-purple-800">???</p>
                    </div>
                </div>
                <!-- Action Reel -->
                <div id="actionReel" class="relative bg-purple-50 p-2 rounded-lg shadow-inner border border-purple-200 flex flex-col items-center justify-center min-h-[80px] overflow-hidden reel-item-container cursor-pointer">
                    <div class="reel-content-wrapper">
                        <p class="text-xl font-bold text-purple-800">???</p>
                    </div>
                </div>
                <!-- Body Part Reel -->
                <div id="bodyPartReel" class="relative bg-purple-50 p-2 rounded-lg shadow-inner border border-purple-200 flex flex-col items-center justify-center min-h-[80px] overflow-hidden reel-item-container cursor-pointer">
                    <div class="reel-content-wrapper">
                        <p class="text-xl font-bold text-purple-800">???</p>
                    </div>
                </div>
                <!-- Player 2 Reel -->
                <div id="player2Reel" class="relative bg-purple-50 p-2 rounded-lg shadow-inner border border-purple-200 flex flex-col items-center justify-center min-h-[80px] overflow-hidden reel-item-container cursor-pointer">
                    <div class="reel-content-wrapper">
                        <p class="text-xl font-bold text-purple-800">???</p>
                    </div>
                </div>
                <!-- Countdown Reel -->
                <div id="countdownReel" class="relative bg-purple-50 p-2 rounded-lg shadow-inner border border-purple-200 flex flex-col items-center justify-center min-h-[80px] overflow-hidden reel-item-container cursor-pointer">
                    <div class="reel-content-wrapper">
                        <p class="text-xl font-bold text-purple-800">???</p>
                    </div>
                </div>
            </div>

            <!-- Affichage des d√©fis pour le Niveau 6 -->
            <div id="level6ChallengesDisplay" class="mt-8 text-center hidden">
                <h3 class="text-3xl font-extrabold text-purple-900 mb-4">Positions de Fusion Ultime !</h3>
                <div id="level6Groups">
                    <!-- Groups will be rendered here by JS -->
                </div>
                <div id="level6SoloPlayers" class="mt-8">
                    <!-- Solo players will be rendered here by JS -->
                </div>
                 <!-- Le rouleau du temps est toujours visible et affiche le temps restant -->
                <div class="relative bg-purple-50 p-2 rounded-lg shadow-inner border border-purple-200 flex flex-col items-center justify-center min-h-[80px] overflow-hidden mt-8 mx-auto max-w-[150px]">
                    <p id="level6CountdownDisplay" class="text-xl font-bold text-purple-800 transition-all duration-75 ease-linear">
                        ???
                    </p>
                </div>
            </div>


            <!-- Bouton de lancement -->
            <button
                id="spinWheelBtn"
                class="relative bg-gradient-to-r from-pink-500 to-purple-600 hover:from-pink-600 hover:to-purple-700 text-white font-bold py-4 px-10 rounded-full shadow-lg transition-all duration-200 ease-in-out transform hover:scale-105 active:scale-95 active:translate-y-1 active:shadow-none text-xl"
            >
                Lancer le Tirage !
            </button>

            <!-- Bouton Lancer Compte √† Rebours -->
            <button
                id="startCountdownBtn"
                class="mt-4 bg-gradient-to-r from-green-500 to-teal-600 hover:from-green-600 hover:to-teal-700 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-all duration-200 ease-in-out transform hover:scale-105 active:scale-95 active:translate-y-1 active:shadow-none hidden"
            >
                Lancer le Compte √† Rebours !
            </button>

            <!-- Bouton Changer de D√©fi Joker -->
            <button
                id="changeJokerChallengeBtn"
                class="mt-4 bg-gradient-to-r from-orange-500 to-red-600 hover:from-orange-600 hover:to-red-700 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-all duration-200 ease-in-out transform hover:scale-105 active:scale-95 active:translate-y-1 active:shadow-none hidden"
            >
                Changer de D√©fi Joker
            </button>
        </div>
    </div>

    <!-- Bouton Mode Admin -->
    <button
        id="adminModeBtn"
        class="absolute top-4 right-4 z-10 bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-6 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105"
    >
        Mode Admin
    </button>

    <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration (√Ä REMPLIR PAR TES PROPRES VALEURS !) ---
        // Colle l'objet firebaseConfig que tu as r√©cup√©r√© de ta console Firebase ici.
        const firebaseConfig = {
            apiKey: "AIzaSyD5cXOysR_4kosu6Ekfdm46tVag6hNCL-Y",
            authDomain: "intimategame-c6e44.firebaseapp.com",
            projectId: "intimategame-c6e44",
            storageBucket: "intimategame-c6e44.firebasestorage.app",
            messagingSenderId: "672263311531",
            appId: "1:672263311531:web:c0720cf33dd932ce64a7ee"
        };

        // Utilise ton projectId comme appId pour la structure de collection Firestore
        const appId = firebaseConfig.projectId;

        // --- Firebase Global Variables ---
        let app;
        let db;
        let auth;
        let userId;

        // --- Variables d'√©tat globales (remplacent les useState de React) ---
        let players = [];
        let newPlayerName = '';
        let newPlayerSex = 'homme';
        let newPlayerAcceptSameSex = true;
        let result = { player1: null, action: '', bodyPart: '', player2: null, countdownTime: 0, isJokerChallenge: false, jokerChallengeText: '' };
        let isSpinning = false; // Indicates if a full spin is in progress
        let showInstructions = true;

        const levelOrder = [
            { id: 'level1', name: 'Niveau 1 (Doux)', actionType: 'doux', bodyPartType: 'doux' },
            { id: 'level2', name: 'Niveau 2 (Moyen)', actionType: 'doux', bodyPartType: 'moyen' }, // Changed bodyPartType to 'moyen'
            { id: 'level3', name: 'Niveau 3 (Interm√©diaire)', actionType: 'moyen', bodyPartType: 'moyen' },
            { id: 'level4', name: 'Niveau 4 (Intense)', actionType: 'moyen', bodyPartType: 'intense' }, // Changed bodyPartType to 'intense'
            { id: 'level5', name: 'Niveau 5 (Ultime)', actionType: 'intense', bodyPartType: 'intense' },
            { id: 'level6', name: 'Niveau 6 (Fusion Ultime)', actionType: 'fusion', bodyPartType: 'intense' }
        ];
        let currentLevelIndex = 0;
        let playerParticipationCounts = {};
        let showLevelUpModal = false;
        let levelUpMessage = '';
        let levelUpTitle = '';

        let remainingTime = 0;
        let isCountingDown = false;
        let countdownInterval = null;
        // let isAudioContextReady = false; // Supprim√© car l'audio n'est plus utilis√©

        let level6Challenges = null;
        let soloPlayersForLevel6 = [];

        // Variables pour les intervalles de spin des rouleaux
        let player1SpinInterval = null;
        let actionSpinInterval = null;
        let bodyPartSpinInterval = null;
        let player2SpinInterval = null;
        let countdownSpinInterval = null;

        const countdownOptions = Array.from({ length: 12 }, (_, i) => `${(i + 1) * 5}s`);


        // Donn√©es par d√©faut (utilis√©es si Firebase est d√©sactiv√© ou pour initialiser)
        const defaultActionsData = {
            doux: ["touche", "caresse", "chatouille", "effleure", "susurre √†", "respire sur", "souffle sur", "embrasse tendrement", "hume"],
            moyen: ["embrasse", "frotte", "masse", "glisse sur", "l√®che doucement", "presse", "mordille"],
            intense: ["l√®che", "suce", "pince", "embrasse passionn√©ment", "caresse sensuellement"],
            fusion: ["La Cuill√®re", "Le Lotus", "Le Papillon", "Le Missionnaire", "La D√©esse", "Le Cavalier", "Le 69", "Le Pont", "L'Arc", "Le Yab-Yum"]
        };
        const defaultBodyPartsData = {
            doux: { neutral: ["le cou", "l'oreille", "le lobe d'oreille", "la nuque", "l'√©paule", "le bras", "la main", "la paume", "les doigts", "le poignet", "le front", "la tempe", "la joue", "la paupi√®re", "le mollet", "la cheville", "le pied", "les orteils", "les cheveux"], homme: [], femme: [] },
            moyen: { neutral: ["la poitrine", "le ventre", "le nombril", "le bas du dos", "la cuisse", "le genou", "l'aisselle", "la hanche", "le coccyx", "la colonne vert√©brale", "les l√®vres", "la langue", "la m√¢choire", "les cheveux"], homme: [], femme: [] },
            intense: { neutral: ["la fesse", "l'int√©rieur de la cuisse", "l'entrejambe", "le p√©rin√©e", "le pli de l'aine", "le t√©ton", "les cheveux"], homme: ["le p√©nis", "le gland", "le scrotum"], femme: ["le clitoris", "les grandes l√®vres", "les petites l√®vres", "le vagin"] }
        };
        const defaultJokerChallengesTemplates = {
            level1: [
                { id: 'joker1-1', template: `**Le regard soutenu :** {player1} et {player2} doivent se regarder dans les yeux sans rire pendant 30 secondes.`, playersNeeded: 2, accessories: [] },
                { id: 'joker1-2', template: `**La cha√Æne de caresses :** Tout le groupe se met en cercle et chaque joueur caresse le dos de la personne devant lui pendant 1 minute.`, playersNeeded: 'all', accessories: [] },
                { id: 'joker1-3', template: `**Le mime sensuel :** {player1} doit mimer une action sensuelle (ex: danser lascivement, manger un fruit avec passion) et les autres devinent.`, playersNeeded: 1, accessories: [] },
                { id: 'joker1-4', template: `**Le compliment intime :** Chaque joueur fait un compliment sinc√®re et intime √† la personne √† sa droite.`, playersNeeded: 'all', accessories: [] },
                { id: 'joker1-5', template: `**La pose suggestive :** Tout le groupe doit prendre une photo de groupe dans une pose suggestive avec un appareil photo/vid√©o. (Accessoire : **appareil photo/vid√©o**)`, playersNeeded: 'all', accessories: ['appareil photo/vid√©o'] },
                { id: 'joker1-6', template: `**La confession sonore :** {player1} doit enregistrer un message vocal intime ou une d√©claration coquine pour le groupe. (Accessoire : **t√©l√©phone/enregistreur**)`, playersNeeded: 1, accessories: ['t√©l√©phone/enregistreur'] },
                { id: 'joker1-7', template: `**Le d√©fi du parfum :** {player1} doit deviner le parfum de {player2} en le sentant sur son cou.`, playersNeeded: 2, accessories: [] },
                { id: 'joker1-8', template: `**Le dessin corporel :** {player1} dessine quelque chose de simple sur le bras de {player2} avec son doigt.`, playersNeeded: 2, accessories: [] },
                { id: 'joker1-9', template: `**Le secret chuchot√© :** {player1} chuchote un secret coquin √† l'oreille de {player2}, qui doit ensuite le chuchoter √† {player3}.`, playersNeeded: 3, accessories: [] },
                { id: 'joker1-10', template: `**La danse du regard :** {player1} et {player2} dansent ensemble en se fixant dans les yeux, sans toucher.`, playersNeeded: 2, accessories: [] },
                { id: 'joker1-11', template: `**Le d√©fi de la "premi√®re impression coquine" :** Chaque joueur doit dire la premi√®re chose coquine qui lui vient √† l'esprit en pensant √† la personne en face de lui/elle.`, playersNeeded: 'all', accessories: [] },
                { id: 'joker1-12', template: `**La "v√©rit√© ou boisson" l√©g√®re :** Le groupe pose des questions l√©g√®res sur les pr√©f√©rences coquines (ex: "Je n'ai jamais embrass√© quelqu'un en public"). Ceux qui ont fait l'action boivent.`, playersNeeded: 'all', accessories: [] }
            ],
            level2: [
                { id: 'joker2-1', template: `**Le massage des pieds :** {player1} masse les pieds de {player2} pendant 1 minute.`, playersNeeded: 2, accessories: [] },
                { id: 'joker2-2', template: `**La d√©gustation √† l'aveugle :** {player1} fait go√ªter un aliment/boisson √† l'aveugle √† {player2} de mani√®re suggestive.`, playersNeeded: 2, accessories: [] },
                { id: 'joker2-3', template: `**Le blindfold challenge (non intime) :** {player1} a les yeux band√©s et doit identifier {player2} en le/la touchant uniquement avec ses l√®vres ou sa langue sur une partie du corps non intime (bras, √©paule, cou). (Accessoire : **bandeau**)`, playersNeeded: 2, accessories: ['bandeau'] },
                { id: 'joker2-4', template: `**La caresse prolong√©e :** {player1} caresse lentement le bras, le cou ou le dos de {player2} pendant 30 secondes.`, playersNeeded: 2, accessories: [] },
                { id: 'joker2-5', template: `**Le souffle chaud :** {player1} souffle doucement sur la nuque ou l'oreille de {player2} pendant 15 secondes.`, playersNeeded: 2, accessories: [] },
                { id: 'joker2-6', template: `**Le d√©fi du contact visuel prolong√© :** Tout le groupe se regarde intens√©ment, un par un, pendant 10 secondes chacun.`, playersNeeded: 'all', accessories: [] },
                { id: 'joker2-7', template: `**Le "Je n'ai jamais..." coquin (niveau 2) :** Le groupe joue √† "Je n'ai jamais..." avec des affirmations plus suggestives. Ceux qui ont fait l'action doivent boire.`, playersNeeded: 'all', accessories: [] },
                { id: 'joker2-8', template: `**Le toucher myst√®re :** {player1} touche une partie du corps de {player2} (par-dessus les v√™tements) et {player2} doit deviner o√π.`, playersNeeded: 2, accessories: [] },
                { id: 'joker2-9', template: `**La lecture sensuelle :** {player1} lit un court passage d'un texte sensuel ou √©rotique √† voix haute pour le groupe.`, playersNeeded: 1, accessories: [] },
                { id: 'joker2-10', template: `**Le d√©fi du "Hot or Not" :** Le groupe d√©signe un joueur, et les autres doivent dire une chose "hot" et une chose "not" sur lui/elle (toujours dans le respect).`, playersNeeded: 'all', accessories: [] },
                { id: 'joker2-11', template: `**Le d√©fi des mains li√©es :** {player1} et {player2} ont une main attach√©e ensemble et doivent accomplir une t√¢che simple (ex: se servir √† boire) en utilisant uniquement leurs mains libres et leur corps. (Accessoire : **foulard/cordelette**)`, playersNeeded: 2, accessories: ['foulard/cordelette'] },
                { id: 'joker2-12', template: `**Le "Truth or Dare" doux :** Le groupe pose des questions de "v√©rit√©" ou des "gages" plus os√©s, mais toujours verbalement ou avec des actions non-contact direct.`, playersNeeded: 'all', accessories: [] }
            ],
            level3: [
                { id: 'joker3-1', template: `**Le baiser surprise :** {player1} doit donner un baiser surprise √† {player2} (sur la joue, le cou, ou la nuque).`, playersNeeded: 2, accessories: [] },
                { id: 'joker3-2', template: `**Le fr√¥lement intime (v√™tements) :** {player1} doit fr√¥ler avec ses l√®vres ou sa langue une zone √©rog√®ne (cou, oreille, t√©ton, entrejambe par-dessus les v√™tements) de {player2} pendant 10 secondes.`, playersNeeded: 2, accessories: [] },
                { id: 'joker3-3', template: `**Le jeu du Gla√ßon (corps) :** Un gla√ßon est pass√© de corps en corps (sur la peau, non intime) jusqu'√† ce qu'il fonde. (Accessoire : **gla√ßon**)`, playersNeeded: 'all', accessories: ['gla√ßon'] },
                { id: 'joker3-4', template: `**Le d√©shabillage partiel :** {player1} doit aider {player2} √† retirer un v√™tement (chaussette, pull, t-shirt) de mani√®re suggestive.`, playersNeeded: 2, accessories: [] },
                { id: 'joker3-5', template: `**Le d√©fi de la respiration :** {player1} et {player2} se placent face √† face, tr√®s proches, et doivent synchroniser leur respiration pendant 1 minute.`, playersNeeded: 2, accessories: [] },
                { id: 'joker3-6', template: `**Le massage des mains sensuel :** {player1} masse les mains de {player2} de mani√®re tr√®s sensuelle et prolong√©e.`, playersNeeded: 2, accessories: [] },
                { id: 'joker3-7', template: `**Le d√©fi du "regard qui d√©shabille" :** {player1} et {player2} se regardent intens√©ment, et chacun doit d√©crire ce qu'il/elle aimerait faire √† l'autre sans le toucher.`, playersNeeded: 2, accessories: [] },
                { id: 'joker3-8', template: `**La danse du corps √† corps :** {player1} et {player2} dansent coll√©-serr√© pendant une chanson lente.`, playersNeeded: 2, accessories: [] },
                { id: 'joker3-9', template: `**Le d√©fi du "soupir" :** {player1} doit faire soupirer {player2} par des caresses l√©g√®res sur des zones non intimes (bras, cou, dos).`, playersNeeded: 2, accessories: [] },
                { id: 'joker3-10', template: `**Le d√©fi du "Body Shot" (non-alcoolis√©) :** {player1} doit boire une boisson non alcoolis√©e directement sur une partie du corps (cou, ventre, cuisse...) de {player2}. (Accessoire : **shot/boisson**)`, playersNeeded: 2, accessories: ['shot/boisson'] },
                { id: 'joker3-11', template: `**Le "strip-poker" l√©ger :** Le groupe joue au poker (ou autre jeu de cartes simple), et chaque fois qu'un joueur perd une manche, il doit retirer un v√™tement (ex: une chaussette, une montre).`, playersNeeded: 'all', accessories: [] },
                { id: 'joker3-12', template: `**La "cha√Æne de baisers" :** Chaque joueur embrasse la personne √† sa droite sur une partie du corps choisie par le groupe (cou, √©paule, main).`, playersNeeded: 'all', accessories: [] }
            ],
            level4: [
                { id: 'joker4-1', template: `**Le baiser sensuel prolong√© :** {player1} et {player2} doivent s'embrasser passionn√©ment (avec la langue) pendant 30 secondes.`, playersNeeded: 2, accessories: [] },
                { id: 'joker4-2', template: `**La danse √©rotique :** {player1} doit faire une danse √©rotique pour le reste du groupe pendant une minute.`, playersNeeded: 1, accessories: [] },
                { id: 'joker4-3', template: `**Le d√©shabillage en duo (sans les mains) :** {player1} et {player2} doivent s'aider mutuellement √† retirer leurs v√™tements (jusqu'√† la nudit√© compl√®te si le niveau le permet, ou en sous-v√™tements) en 30 secondes, sans utiliser leurs mains.`, playersNeeded: 2, accessories: [] },
                { id: 'joker4-4', template: `**Le d√©fi du "Strip-Tease √† l'aveugle" :** {player1} a les yeux band√©s et doit faire un strip-tease jusqu'√† la nudit√© compl√®te (si le niveau le permet) ou en sous-v√™tements pour le groupe. (Accessoire : **bandeau**)`, playersNeeded: 1, accessories: ['bandeau'] },
                { id: 'joker4-5', template: `**Le d√©fi du sex toy partag√© (sur v√™tements) :** {player1} doit utiliser un sex toy (imaginaire ou r√©el) sur {player2} pendant 1 minute, en se concentrant sur les zones √©rog√®nes par-dessus les v√™tements. (Accessoire : **sex toy (optionnel)**)`, playersNeeded: 2, accessories: ['sex toy (optionnel)'] },
                { id: 'joker4-6', template: `**Le massage √† l'huile (zones plus intimes, sur v√™tements) :** {player1} doit masser {player2} avec de l'huile (imaginaire ou r√©elle) sur les fesses ou l'int√©rieur des cuisses par-dessus les v√™tements pendant 2 minutes. (Accessoire : **huile de massage (optionnel)**)`, playersNeeded: 2, accessories: ['huile de massage (optionnel)'] },
                { id: 'joker4-7', template: `**Le d√©fi du "l√®che-doigt" :** {player1} l√®che le doigt de {player2} de mani√®re suggestive.`, playersNeeded: 2, accessories: [] },
                { id: 'joker4-8', template: `**Le "strip-poker" avanc√© :** Le groupe joue au poker (ou autre jeu de cartes simple), et chaque fois qu'un joueur perd une manche, il doit retirer un v√™tement plus significatif (ex: chemise, pantalon) jusqu'au niveau de nudit√© autoris√©.`, playersNeeded: 'all', accessories: [] },
                { id: 'joker4-9', template: `**Le d√©fi du "chuchotement intime" :** {player1} chuchote un fantasme intime √† l'oreille de {player2}, qui doit le r√©p√©ter √† voix haute.`, playersNeeded: 2, accessories: [] },
                { id: 'joker4-10', template: `**Le Body Shot (alcoolis√© ou non) :** {player1} doit boire un shot (alcoolis√© ou non) directement sur une partie du corps (cou, ventre, cuisse...) de {player2}. (Accessoire : **shot/boisson**)`, playersNeeded: 2, accessories: ['shot/boisson'] },
                { id: 'joker4-11', template: `**Le blindfold challenge (toucher intime sur v√™tements) :** {player1} a les yeux band√©s et doit identifier {player2} en le/la touchant uniquement avec ses l√®vres ou sa langue sur une partie du corps intime (poitrine, fesses, entrejambe) par-dessus les v√™tements. (Accessoire : **bandeau**)`, playersNeeded: 2, accessories: ['bandeau'] },
                { id: 'joker4-12', template: `**Le d√©fi de la "sculpture corporelle" :** {player1} utilise ses mains pour "sculpter" le corps de {player2} par-dessus les v√™tements, en cr√©ant une pose suggestive.`, playersNeeded: 2, accessories: [] }
            ],
            level5: [
                { id: 'joker5-1', template: `**Le Body Shot Ultime :** {player1} doit boire un shot (alcoolis√© ou non) directement sur une zone √©rog√®ne (ex: t√©ton, nombril, entrejambe) de {player2}. (Accessoire : **shot/boisson**)`, playersNeeded: 2, accessories: ['shot/boisson'] },
                { id: 'joker5-2', template: `**Le baiser profond et prolong√© :** {player1} et {player2} doivent s'embrasser passionn√©ment, en explorant la bouche de l'autre, pendant au moins 1 minute.`, playersNeeded: 2, accessories: [] },
                { id: 'joker5-3', template: `**La danse √©rotique compl√®te :** {player1} doit faire une danse √©rotique compl√®te pour le reste du groupe.`, playersNeeded: 1, accessories: [] },
                { id: 'joker5-4', template: `**Le fr√¥lement intime (peau) :** {player1} doit fr√¥ler avec ses l√®vres ou sa langue une zone √©rog√®ne (cou, oreille, t√©ton, entrejambe) de {player2} pendant 10 secondes, directement sur la peau. (Accessoire : **bandeau**)`, playersNeeded: 2, accessories: [] },
                { id: 'joker5-5', template: `**La confession ultime :** Chaque joueur doit r√©v√©ler le fantasme le plus audacieux qu'il n'a jamais r√©alis√©, en d√©taillant.`, playersNeeded: 'all', accessories: [] },
                { id: 'joker5-6', template: `**Le jeu du Gla√ßon (bouche √† bouche ou corps √† corps intime) :** Un gla√ßon est pass√© de bouche en bouche (ou de corps en corps sur des zones intimes) jusqu'√† ce qu'il fonde, en utilisant uniquement la langue ou les l√®vres. (Accessoire : **gla√ßon**)`, playersNeeded: 'all', accessories: ['gla√ßon'] },
                { id: 'joker5-7', template: `**La question sans filtre (extr√™me) :** Chaque joueur pose une question √† un autre joueur, et la r√©ponse doit √™tre absolument honn√™te et sans filtre, quelle que soit l'intimit√© ou la g√™ne potentielle de la question.`, playersNeeded: 'all', accessories: [] },
                { id: 'joker5-8', template: `**Le massage mutuel nu :** {player1} et {player2} doivent se faire un massage mutuel, nus, pendant 2 minutes. (Accessoire : **huile de massage (optionnel)**)`, playersNeeded: 2, accessories: ['huile de massage (optionnel)'] },
                { id: 'joker5-9', template: `**La d√©gustation du corps :** {player1} doit l√©cher une partie du corps de {player2} (ex: cou, √©paule, ventre, fesse) et deviner une saveur (sel, sucre, etc.) qui y aurait √©t√© d√©pos√©e.`, playersNeeded: 2, accessories: [] },
                { id: 'joker5-10', template: `**Le blindfold challenge (toucher intime sur peau) :** {player1} a les yeux band√©s et doit identifier {player2} en le/la touchant uniquement avec ses l√®vres ou sa langue sur une partie du corps intime (poitrine, fesses, entrejambe) directement sur la peau. (Accessoire : **bandeau**)`, playersNeeded: 2, accessories: ['bandeau'] },
                { id: 'joker5-11', template: `**Le d√©fi du "toucher intime" :** {player1} doit toucher une zone intime (poitrine, fesses, entrejambe) de {player2} pendant 10 secondes.`, playersNeeded: 2, accessories: [] },
                { id: 'joker5-12', template: `**Le d√©fi du "bain de bouche partag√©" :** {player1} prend une gorg√©e d'une boisson et la passe de bouche √† bouche √† {player2}.`, playersNeeded: 2, accessories: [] },
                { id: 'joker5-13', template: `**La douche sensuelle en groupe :** {player1} doit doucher sensuellement {player2} (nus, si le niveau le permet), tandis que le reste du groupe assiste √† ce moment. L'objectif est de cr√©er une ambiance √©rotique et intime. (Accessoires : **douche/eau, savon/gel douche (optionnel)**)`, playersNeeded: 2, accessories: ['douche/eau', 'savon/gel douche (optionnel)'] },
                { id: 'joker5-14', template: `**Le d√©fi du "Body Painting Intime" :** {player1} utilise de la peinture corporelle comestible (ou non) pour peindre une zone intime de {player2}, que {player3} doit ensuite l√©cher. (Accessoire : **peinture corporelle comestible (optionnel)**)`, playersNeeded: 3, accessories: ['peinture corporelle comestible (optionnel)'] },
                { id: 'joker5-15', template: `**Le d√©fi de la "cha√Æne de baisers intimes" :** Chaque joueur embrasse la personne √† sa droite sur une zone intime choisie par le groupe (ex: t√©ton, entrejambe).`, playersNeeded: 'all', accessories: [] },
                { id: 'joker5-16', template: `**Le Cercle de Souffles Intimes :** Tout le groupe s'allonge en cercle, la t√™te positionn√©e au niveau des hanches ou des cuisses du voisin. Chaque participant doit se concentrer sur la respiration de la personne dont la t√™te est pr√®s de son entrejambe, en cherchant √† synchroniser les souffles et √† ressentir l'intimit√© de cette proximit√©.`, playersNeeded: 'all', accessories: [] }
            ]
        };

        let actionsData = {};
        let bodyPartsData = {};
        let jokerChallengesTemplates = {};

        // Mode Admin
        let isAdminMode = false;
        let adminPassword = '';
        const ADMIN_SECRET_PASSWORD = 'admin'; // Changed to a simpler password for testing

        // √âtats pour l'√©dition des donn√©es en mode admin (maintenant des objets structur√©s)
        let editableActions = {};
        let editableBodyParts = {};
        let editableJokerChallenges = {};


        // --- R√©f√©rences aux √©l√©ments DOM ---
        const body = document.body;
        const instructionsModal = document.getElementById('instructionsModal');
        const closeInstructionsBtn = document.getElementById('closeInstructions');
        const errorModal = document.getElementById('errorModal');
        const errorMessageTitle = document.getElementById('errorMessageTitle');
        const errorMessageText = document.getElementById('errorMessageText');
        const closeErrorModalBtn = document.getElementById('closeErrorModal');
        const levelUpModal = document.getElementById('levelUpModal');
        const levelUpTitleElem = document.getElementById('levelUpTitle');
        const levelUpMessageElem = document.getElementById('levelUpMessage');
        const closeLevelUpModalBtn = document.getElementById('closeLevelUpModal');
        const adminModal = document.getElementById('adminModal');
        const adminModeBtn = document.getElementById('adminModeBtn');
        const adminAuthSection = document.getElementById('adminAuthSection');
        const adminPasswordInput = document.getElementById('adminPasswordInput');
        const validateAdminPasswordBtn = document.getElementById('validateAdminPassword');
        const adminContent = document.getElementById('adminContent');
        const closeAdminModalBtn = document.getElementById('closeAdminModal');

        const newPlayerNameInput = document.getElementById('newPlayerName');
        const newPlayerSexRadios = document.querySelectorAll('input[name="newPlayerSex"]');
        const newPlayerAcceptSameSexCheckbox = document.getElementById('newPlayerAcceptSameSex');
        const addPlayerBtn = document.getElementById('addPlayerBtn');
        const addTenPlayersBtn = document.getElementById('addTenPlayersBtn');
        const playersListDiv = document.getElementById('playersList');
        const playerCountMessageElem = document.getElementById('playerCountMessage');
        const levelSelect = document.getElementById('level-select');
        const tensionFill = document.getElementById('tensionFill');
        const currentLevelNameElem = document.getElementById('currentLevelName');
        const currentLevelTypesElem = document.getElementById('currentLevelTypes');

        const resultPhraseDisplay = document.getElementById('resultPhraseDisplay');
        const resultTextElem = document.getElementById('resultText');

        // R√©f√©rences aux conteneurs des rouleaux
        const player1ReelContainer = document.getElementById('player1Reel');
        const actionReelContainer = document.getElementById('actionReel');
        const bodyPartReelContainer = document.getElementById('bodyPartReel');
        const player2ReelContainer = document.getElementById('player2Reel');
        const countdownReelContainer = document.getElementById('countdownReel');

        // R√©f√©rences aux √©l√©ments de contenu des rouleaux (pour l'animation)
        const player1ReelContent = player1ReelContainer.querySelector('p');
        const actionReelContent = actionReelContainer.querySelector('p');
        const bodyPartReelContent = bodyPartReelContainer.querySelector('p');
        const player2ReelContent = player2ReelContainer.querySelector('p');
        const countdownReelContent = countdownReelContainer.querySelector('p');


        const gameReelsDiv = document.getElementById('gameReels');
        const level6ChallengesDisplay = document.getElementById('level6ChallengesDisplay');
        const level6GroupsDiv = document.getElementById('level6Groups');
        const level6SoloPlayersDiv = document.getElementById('level6SoloPlayers');
        const level6CountdownDisplay = document.getElementById('level6CountdownDisplay');

        const spinWheelBtn = document.getElementById('spinWheelBtn');
        const startCountdownBtn = document.getElementById('startCountdownBtn');
        const changeJokerChallengeBtn = document.getElementById('changeJokerChallengeBtn');

        const actionsEditorDiv = document.getElementById('actionsEditor');
        const saveActionsDataBtn = document.getElementById('saveActionsData');
        const bodyPartsEditorDiv = document.getElementById('bodyPartsEditor');
        const saveBodyPartsDataBtn = document.getElementById('saveBodyPartsData');
        const jokerChallengesEditorDiv = document.getElementById('jokerChallengesEditor');
        const saveJokerChallengesDataBtn = document.getElementById('saveJokerChallengesData');

        // R√©f√©rences aux √©l√©ments <details> principaux de la modale admin
        const adminActionsDetails = document.getElementById('adminActionsDetails');
        const adminBodyPartsDetails = document.getElementById('adminBodyPartsDetails');
        const adminJokerChallengesDetails = document.getElementById('adminJokerChallengesDetails');


        // --- Fonctions utilitaires ---

        function showModal(modalElement) {
            console.log(`DEBUG: Showing modal: ${modalElement.id}`);
            modalElement.classList.remove('hidden');
        }

        function hideModal(modalElement) {
            console.log(`DEBUG: Hiding modal: ${modalElement.id}`);
            modalElement.classList.add('hidden');
        }

        // Nouvelle fonction pour afficher les messages (succ√®s ou erreur)
        function showMessageModal(message, type = 'error', autoHide = false) {
            const modal = errorModal; // Utilise la modale d'erreur existante
            const titleElem = errorMessageTitle;
            const messageElem = errorMessageText;
            const closeButton = closeErrorModalBtn;

            messageElem.innerHTML = message;

            // R√©initialiser les classes pour √©viter les conflits
            titleElem.classList.remove('text-red-600', 'text-green-600');
            closeButton.classList.remove('bg-red-500', 'hover:bg-red-600', 'bg-green-500', 'hover:bg-green-600');

            if (type === 'success') {
                titleElem.textContent = "Succ√®s !";
                titleElem.classList.add('text-green-600');
                closeButton.classList.add('bg-green-500', 'hover:bg-green-600');
                closeButton.textContent = "OK";
            } else { // type === 'error'
                titleElem.textContent = "Erreur !";
                titleElem.classList.add('text-red-600');
                closeButton.classList.add('bg-red-500', 'hover:bg-red-600');
                closeButton.textContent = "Compris";
            }

            showModal(modal);

            if (autoHide) {
                setTimeout(() => {
                    hideModal(modal);
                    // R√©initialiser les styles de la modale √† l'√©tat d'erreur par d√©faut apr√®s masquage
                    titleElem.classList.remove('text-green-600');
                    titleElem.classList.add('text-red-600');
                    closeButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    closeButton.classList.add('bg-red-500', 'hover:bg-red-600');
                    closeButton.textContent = "Compris";
                }, 3000); // Masquer apr√®s 3 secondes
            }
        }


        function getColoredName(player) {
            const colorClass = player.sex === 'homme' ? 'text-blue-600' : 'text-pink-600';
            return `<span class="font-bold ${colorClass}">${player.name}</span>`;
        }

        function getRandomPlayer(excludePlayer = null) {
            const availablePlayers = players.filter(p => p.name !== excludePlayer?.name);
            if (availablePlayers.length === 0) return null;
            return availablePlayers[Math.floor(Math.random() * availablePlayers.length)];
        }

        function checkCompatibility(p1, p2) {
            if (!p1 || !p2 || p1.name === p2.name) return false;
            if (p1.sex === p2.sex) {
                return p1.acceptSameSex && p2.acceptSameSex;
            }
            return true;
        }

        function getTwoCompatiblePlayers() {
            if (players.length < 2) return [null, null];
            let p1, p2, attempts = 0;
            const maxAttempts = 100;
            do {
                p1 = players[Math.floor(Math.random() * players.length)];
                p2 = players[Math.floor(Math.random() * players.length)];
                attempts++;
            } while ((p1.name === p2.name || !checkCompatibility(p1, p2)) && attempts < maxAttempts);
            return [p1, p2];
        }

        function getThreeCompatiblePlayers() {
            if (players.length < 3) return [null, null, null];
            let p1, p2, p3, attempts = 0;
            const maxAttempts = 100;
            do {
                p1 = players[Math.floor(Math.random() * players.length)];
                p2 = players[Math.floor(Math.random() * players.length)];
                p3 = players[Math.floor(Math.random() * players.length)];
                attempts++;
            } while ((p1.name === p2.name || p1.name === p3.name || p2.name === p3.name || !checkCompatibility(p1, p2) || !checkCompatibility(p1, p3) || !checkCompatibility(p2, p3)) && attempts < maxAttempts);
            return [p1, p2, p3];
        }

        function generateJokerChallengeText(challengeTemplate) {
            let text = challengeTemplate.template;
            const needed = challengeTemplate.playersNeeded;

            let selectedPlayers = [];
            if (needed === 1) {
                const p = getRandomPlayer();
                if (p) selectedPlayers.push(p);
            } else if (needed === 2) {
                selectedPlayers = getTwoCompatiblePlayers();
            } else if (needed === 3) {
                selectedPlayers = getThreeCompatiblePlayers();
            } else if (needed === 'all') {
                selectedPlayers = players;
            }

            if (selectedPlayers.some(p => p === null || p === undefined) || (needed !== 'all' && selectedPlayers.length < needed)) {
                return "Pas assez de joueurs pour ce d√©fi Joker.";
            }

            selectedPlayers.forEach((player, index) => {
                text = text.replace(`{player${index + 1}}`, getColoredName(player));
            });
            return text;
        }

        function getJokerChallengesForLevel(levelId) {
            return jokerChallengesTemplates[levelId] || [];
        }

        // Fonction pour d√©marrer le spin d'un seul rouleau
        function startReelSpin(reelElement, options) {
            let intervalId = setInterval(() => {
                const randomIndex = Math.floor(Math.random() * options.length);
                reelElement.innerHTML = options[randomIndex];
            }, 50); // Mettre √† jour toutes les 50ms pour un effet de spin rapide
            return intervalId;
        }

        // Fonction pour arr√™ter le spin d'un seul rouleau et d√©finir sa valeur finale
        function stopReelSpin(intervalId, reelElement, finalValue, textColorClass = 'text-purple-800') {
            clearInterval(intervalId);
            reelElement.innerHTML = finalValue;
            // Appliquer la classe de couleur si fournie (pour les joueurs)
            reelElement.className = `text-xl font-bold ${textColorClass} transition-colors duration-300 ease-in-out`;
        }


        // --- Fonctions d'initialisation et de rendu de l'UI ---

        function renderPlayersList() {
            playersListDiv.innerHTML = ''; // Vider la liste actuelle
            if (players.length > 0) {
                playersListDiv.classList.remove('hidden');
                const currentLevelId = levelOrder[currentLevelIndex].id; // Get the current level ID

                players.forEach((player, index) => {
                    // Get participation count for the current level, default to 0 if not found
                    const participationCount = playerParticipationCounts[player.name]?.[currentLevelId] || 0;

                    const playerDiv = document.createElement('div');
                    playerDiv.className = "flex flex-col items-start bg-purple-100 text-purple-800 py-2 px-4 rounded-lg shadow-sm text-sm font-medium relative";
                    playerDiv.innerHTML = `
                        <button class="absolute top-1 right-2 text-purple-600 hover:text-purple-900 font-bold text-lg leading-none transition duration-200 remove-player-btn" data-index="${index}">
                            &times;
                        </button>
                        <div class="flex items-center gap-2">
                            <span class="font-bold text-base">${player.name}</span>
                            <span class="text-base font-semibold text-purple-600">| ${participationCount}</span>
                        </div>
                        <span class="text-xs text-gray-600">Sexe: ${player.sex === 'homme' ? 'Homme' : 'Femme'}</span>
                        <span class="text-xs text-gray-600">M√™me sexe: ${player.acceptSameSex ? 'Oui' : 'Non'}</span>
                    `;
                    playersListDiv.appendChild(playerDiv);
                });
                // Attacher les √©couteurs d'√©v√©nements aux nouveaux boutons de suppression
                playersListDiv.querySelectorAll('.remove-player-btn').forEach(button => {
                    button.onclick = async (e) => { // Added async
                        await removePlayer(parseInt(e.target.dataset.index)); // Await the removePlayer call
                    };
                });
            } else {
                playersListDiv.classList.add('hidden');
            }

            // Mettre √† jour le message du nombre de joueurs
            if (players.length < 2) {
                playerCountMessageElem.textContent = `Ajoute au moins ${2 - players.length} joueur(s) pour commencer !`;
                playerCountMessageElem.classList.remove('hidden');
                spinWheelBtn.disabled = true;
            } else if (players.length >= 10) {
                playerCountMessageElem.textContent = "Maximum de 10 joueurs atteint !";
                playerCountMessageElem.classList.remove('hidden');
                addPlayerBtn.disabled = true;
            } else {
                playerCountMessageElem.classList.add('hidden');
                spinWheelBtn.disabled = false;
                addPlayerBtn.disabled = false;
            }
            // addTenPlayersBtn should be enabled only if no players are present
            addTenPlayersBtn.disabled = players.length > 0;
        }

        function renderLevelSelect() {
            levelSelect.innerHTML = '';
            levelOrder.forEach((level, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = level.name;
                levelSelect.appendChild(option);
            });
            levelSelect.value = currentLevelIndex; // S'assurer que la s√©lection est √† jour
        }

        function updateTensionBar() {
            const tensionFillHeight = `${((currentLevelIndex + 1) / levelOrder.length) * 100}%`;
            tensionFill.style.height = tensionFillHeight;

            const currentLevel = levelOrder[currentLevelIndex];
            currentLevelNameElem.textContent = currentLevel.name;
            currentLevelTypesElem.innerHTML = `
                Actions : <span class="font-semibold text-purple-700">${currentLevel.actionType.charAt(0).toUpperCase() + currentLevel.actionType.slice(1)}</span> /
                Zones : <span class="font-semibold text-purple-700">${currentLevel.bodyPartType.charAt(0).toUpperCase() + currentLevel.bodyPartType.slice(1)}</span>
            `;

            // Mettre √† jour la couleur de fond du body
            const backgroundGradients = [
                'from-blue-100 via-blue-200 to-purple-200',
                'from-purple-200 via-pink-200 to-rose-300',
                'from-pink-300 via-purple-300 to-indigo-400',
                'from-red-400 via-pink-500 to-purple-500',
                'from-red-600 via-purple-700 to-pink-700',
                'from-purple-700 via-red-800 to-pink-800'
            ];
            body.className = `min-h-screen bg-gradient-to-br ${backgroundGradients[currentLevelIndex]} flex flex-col items-center justify-center p-4 text-gray-800 pb-16 transition-all duration-1000 ease-in-out`;
        }

        function updateReelsDisplay() {
            if (currentLevelIndex < 5) {
                gameReelsDiv.classList.remove('hidden');
                level6ChallengesDisplay.classList.add('hidden');
                resultPhraseDisplay.classList.remove('hidden'); // Show result phrase for levels 1-5

                // Pendant le spinning, le contenu est mis √† jour par startReelSpin.
                // Quand ce n'est pas en spinning, on affiche la valeur finale.
                if (!isSpinning) { // Only update content and classes if not spinning
                    const p1Text = result.isJokerChallenge ? 'J' : (result.player1?.name || '???');
                    const actionText = result.isJokerChallenge ? 'O' : (result.action || '???');
                    const bodyPartText = result.isJokerChallenge ? 'K' : (result.bodyPart || '???');
                    const p2Text = result.isJokerChallenge ? 'E' : (result.player2?.name || '???');
                    const countdownText = result.isJokerChallenge ? 'R' : (result.countdownTime ? `${result.countdownTime}s` : '???');

                    player1ReelContent.innerHTML = p1Text;
                    actionReelContent.innerHTML = actionText;
                    bodyPartReelContent.innerHTML = bodyPartText;
                    player2ReelContent.innerHTML = p2Text;
                    countdownReelContent.innerHTML = countdownText;

                    const p1Color = result.player1?.sex === 'homme' ? 'text-blue-600' : 'text-pink-600';
                    const p2Color = result.player2?.sex === 'homme' ? 'text-blue-600' : 'text-pink-600';

                    player1ReelContent.className = `text-xl font-bold ${result.isJokerChallenge ? 'text-purple-800' : p1Color} transition-colors duration-300 ease-in-out`;
                    actionReelContent.className = `text-xl font-bold text-purple-800 transition-colors duration-300 ease-in-out`;
                    bodyPartReelContent.className = `text-xl font-bold text-purple-800 transition-colors duration-300 ease-in-out`;
                    player2ReelContent.className = `text-xl font-bold ${result.isJokerChallenge ? 'text-purple-800' : p2Color} transition-colors duration-300 ease-in-out`;
                    countdownReelContent.className = `text-xl font-bold text-purple-800 transition-colors duration-300 ease-in-out`;

                    // Ensure spinning class is removed if not spinning
                    player1ReelContainer.classList.remove('spinning');
                    actionReelContainer.classList.remove('spinning');
                    bodyPartReelContainer.classList.remove('spinning');
                    player2ReelContainer.classList.remove('spinning');
                    countdownReelContainer.classList.remove('spinning');
                }


                // Construct and display the result phrase
                if (result.isJokerChallenge) {
                    // MODIFICATION ICI : Suppression de l'affichage du temps pour les d√©fis Joker
                    resultTextElem.innerHTML = `**D√âFI JOKER !** ${result.jokerChallengeText}`;
                } else if (result.player1 && result.player2 && result.action && result.bodyPart) {
                    resultTextElem.innerHTML = `${getColoredName(result.player1)} ${result.action} ${result.bodyPart} de ${getColoredName(result.player2)} pendant ${result.countdownTime} secondes !`;
                } else {
                    resultTextElem.innerHTML = 'Lance le tirage pour voir le d√©fi !';
                    resultPhraseDisplay.classList.add('hidden'); // Hide if no result yet
                }

                // Show/hide specific buttons
                startCountdownBtn.classList.add('hidden');
                changeJokerChallengeBtn.classList.add('hidden');

                if (result.countdownTime > 0 && !isSpinning && (result.player1 || result.isJokerChallenge)) { // Only show if a valid result exists
                    startCountdownBtn.classList.remove('hidden');
                }
                if (result.isJokerChallenge && !isSpinning) {
                    changeJokerChallengeBtn.classList.remove('hidden');
                }

            } else { // Niveau 6
                gameReelsDiv.classList.add('hidden');
                resultPhraseDisplay.classList.add('hidden'); // Hide result phrase for Level 6
                level6ChallengesDisplay.classList.remove('hidden');

                level6GroupsDiv.innerHTML = '';
                if (level6Challenges && level6Challenges.length > 0) {
                    level6Challenges.forEach((group, idx) => {
                        // Corrected player HTML generation to avoid "false"
                        let playersHtmlArray = group.players.map(player => getColoredName(player));
                        let playersHtml = '';
                        if (playersHtmlArray.length === 2) {
                            playersHtml = `${playersHtmlArray[0]} et ${playersHtmlArray[1]}`;
                        } else if (playersHtmlArray.length > 2) {
                            const lastPlayer = playersHtmlArray.pop();
                            playersHtml = `${playersHtmlArray.join(', ')} et ${lastPlayer}`;
                        } else if (playersHtmlArray.length === 1) {
                            playersHtml = playersHtmlArray[0];
                        }

                        // Split the challenge string to insert a line break
                        let challengeParts = group.challenge.split('. Le d√©fi se termine par une √©jaculation sur ');
                        let positionText = challengeParts[0];
                        let kissText = '';

                        if (challengeParts.length > 1) {
                            positionText += '.'; // Re-add the period to the position
                            kissText = 'Le d√©fi se termine par une √©jaculation sur ' + challengeParts.slice(1).join('. Le d√©fi se termine par une √©jaculation sur '); // Reconstruct kiss part
                        } else {
                            // If no split occurred, the whole challenge is the position
                            positionText = group.challenge;
                        }


                        const groupDiv = document.createElement('div');
                        groupDiv.className = "mb-4"; // Add margin bottom for spacing between groups
                        groupDiv.innerHTML = `
                            <p class="text-2xl md:text-3xl font-extrabold text-purple-900 leading-tight mb-1">
                                ${playersHtml}
                            </p>
                            <p class="text-xl md:text-2xl font-semibold text-gray-800 leading-tight">
                                ${positionText}
                                ${kissText ? '<br/>' + kissText : ''}
                            </p>
                        `;
                        level6GroupsDiv.appendChild(groupDiv);

                        // Add separator if it's not the last group
                        if (idx < level6Challenges.length - 1) {
                            const separator = document.createElement('div');
                            separator.className = "text-pink-500 text-3xl my-6";
                            separator.innerHTML = "üíìüíìüíì";
                            level6GroupsDiv.appendChild(separator);
                        }
                    });
                } else {
                    level6GroupsDiv.innerHTML = '<p class="text-xl text-gray-600">Aucun groupe form√© pour le moment. Ajoutez des joueurs ou ajustez les pr√©f√©rences pour le Niveau 6.</p>';
                }

                level6SoloPlayersDiv.innerHTML = '';
                if (soloPlayersForLevel6.length > 0) {
                    const h4 = document.createElement('h4');
                    h4.className = "text-2xl font-bold text-gray-700 mb-2";
                    h4.textContent = "D√©fis Personnels :";
                    level6SoloPlayersDiv.appendChild(h4);

                    soloPlayersForLevel6.forEach((player, idx) => {
                        const p = document.createElement('p');
                        p.className = "text-xl md:text-2xl font-extrabold text-gray-800 leading-tight mb-1";
                        const colorClass = player.sex === 'homme' ? 'text-blue-600' : 'text-pink-600';
                        p.innerHTML = `<span class="font-bold ${colorClass}">${player.name}</span> est invit√©(e) √† profiter du spectacle en se masturbant. Participation possible !.`;
                        level6SoloPlayersDiv.appendChild(p);
                    });
                }
                level6CountdownDisplay.textContent = isCountingDown ? remainingTime : (result.countdownTime ? `${result.countdownTime}s` : '???');

                // Show/hide specific buttons for Level 6
                startCountdownBtn.classList.remove('hidden');
                changeJokerChallengeBtn.classList.add('hidden'); // Joker button not relevant for Level 6
            }

            // Update spin button state
            spinWheelBtn.disabled = players.length < 2 || isSpinning || isCountingDown;
            spinWheelBtn.textContent = isSpinning ? 'En cours...' : 'Lancer le Tirage !';
            spinWheelBtn.classList.toggle('hover:scale-105', !isSpinning);
            spinWheelBtn.classList.toggle('active:scale-95', !isSpinning);
            spinWheelBtn.classList.toggle('active:translate-y-1', !isSpinning);
            spinWheelBtn.classList.toggle('active:shadow-none', !isSpinning);

            startCountdownBtn.disabled = isCountingDown;
            startCountdownBtn.textContent = isCountingDown ? `Compte √† rebours : ${remainingTime}s` : 'Lancer le Compte √† Rebours !';

            changeJokerChallengeBtn.disabled = isSpinning || isCountingDown;
        }

        function renderAdminActions() {
            console.log("DEBUG: renderAdminActions called. editableActions state:", editableActions);
            // Capture current open state
            const wasOpen = adminActionsDetails.open;

            actionsEditorDiv.innerHTML = ''; // Clear existing content
            const orderedLevels = ['doux', 'moyen', 'intense', 'fusion']; // Define order

            let hasContent = false;
            orderedLevels.forEach(level => {
                const levelData = editableActions[level];
                const levelDetails = document.createElement('details'); // Main collapsible for each level
                levelDetails.className = "mb-4 bg-gray-100 rounded-lg shadow-sm";
                // Preserve open state for this specific level's details
                const currentLevelDetailsElem = actionsEditorDiv.querySelector(`details[data-level="${level}"]`);
                if (currentLevelDetailsElem) {
                    levelDetails.open = currentLevelDetailsElem.open;
                }

                levelDetails.innerHTML = `
                    <summary class="collapsible-header text-xl font-semibold text-gray-700 capitalize">
                        ${level}
                        <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                    </summary>
                    <div class="collapsible-content nested-collapsible-content space-y-3" id="actions-${level}-content">
                        <!-- Content for actions will be rendered here -->
                    </div>
                `;
                // Add data-level attribute for easier selection
                levelDetails.setAttribute('data-level', level);
                const levelContentDiv = levelDetails.querySelector(`#actions-${level}-content`);

                if (levelData && Array.isArray(levelData)) {
                    if (levelData.length > 0) {
                        hasContent = true;
                        levelData.forEach((action, index) => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = "flex items-center gap-2 mb-2";
                            itemDiv.innerHTML = `
                                <input type="text" value="${action}" data-level="${level}" data-index="${index}" class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-purple-400 outline-none action-input" />
                                <button class="bg-red-400 hover:bg-red-500 text-white p-2 rounded-full text-sm transition duration-200 remove-action-btn" data-level="${level}" data-index="${index}">&times;</button>
                            `;
                            levelContentDiv.appendChild(itemDiv);
                        });
                    }
                } else {
                    console.warn(`DEBUG: editableActions[${level}] est vide ou non un tableau.`);
                    editableActions[level] = [];
                }

                const addBtn = document.createElement('button');
                addBtn.className = "bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-full text-sm mt-3 transition duration-200";
                addBtn.textContent = "Ajouter Action";
                addBtn.onclick = () => {
                    editableActions[level].push('');
                    renderAdminActions(); // Re-render to show new input
                };
                levelContentDiv.appendChild(addBtn);
                actionsEditorDiv.appendChild(levelDetails); // Append the details element
            });

            if (!hasContent && Object.keys(editableActions).length === 0) {
                actionsEditorDiv.innerHTML = '<p class="text-red-500 text-center">Aucune donn√©e d\'action charg√©e. V√©rifiez la console pour les erreurs Firebase.</p>';
            }

            // Restore main details open state
            adminActionsDetails.open = wasOpen;

            // Attach listeners AFTER all elements are in the DOM
            actionsEditorDiv.querySelectorAll('.action-input').forEach(input => {
                input.oninput = (e) => {
                    const level = e.target.dataset.level;
                    const index = parseInt(e.target.dataset.index);
                    editableActions[level][index] = e.target.value;
                };
            });
            actionsEditorDiv.querySelectorAll('.remove-action-btn').forEach(button => {
                button.onclick = (e) => {
                    const level = e.target.dataset.level;
                    const index = parseInt(e.target.dataset.index);
                    editableActions[level] = editableActions[level].filter((_, i) => i !== index);
                    renderAdminActions(); // Re-render after removal
                };
            });
        }

        function renderAdminBodyParts() {
            console.log("DEBUG: renderAdminBodyParts called. editableBodyParts state:", editableBodyParts);
            // Capture current open state for main and nested details
            const wasMainOpen = adminBodyPartsDetails.open;
            const nestedOpenStates = {};
            adminBodyPartsDetails.querySelectorAll('details[data-level]').forEach(levelDetail => {
                nestedOpenStates[levelDetail.dataset.level] = {};
                levelDetail.querySelectorAll('details[data-category]').forEach(categoryDetail => {
                    nestedOpenStates[levelDetail.dataset.level][categoryDetail.dataset.category] = categoryDetail.open;
                });
            });


            bodyPartsEditorDiv.innerHTML = ''; // Clear existing content
            const orderedLevels = ['doux', 'moyen', 'intense']; // Define order for main levels
            const orderedSexCategories = ['neutral', 'femme', 'homme']; // Define order for sex categories

            let hasContent = false;
            orderedLevels.forEach(level => {
                const levelData = editableBodyParts[level];
                const levelDetails = document.createElement('details');
                levelDetails.className = "mb-4 bg-gray-100 rounded-lg shadow-sm";
                // Preserve open state for this specific level's details
                const currentLevelDetailsElem = bodyPartsEditorDiv.querySelector(`details[data-level="${level}"]`);
                if (currentLevelDetailsElem) {
                    levelDetails.open = currentLevelDetailsElem.open;
                }
                levelDetails.setAttribute('data-level', level); // Add data-level attribute

                levelDetails.innerHTML = `
                    <summary class="collapsible-header text-xl font-semibold text-gray-700 capitalize">
                        ${level}
                        <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                    </summary>
                    <div class="collapsible-content nested-collapsible-content space-y-3" id="bodyParts-${level}-content">
                        <!-- Content for sex categories will be rendered here -->
                    </div>
                `;
                const levelContentDiv = levelDetails.querySelector(`#bodyParts-${level}-content`);

                orderedSexCategories.forEach(sexCategory => {
                    const categoryData = levelData ? levelData[sexCategory] : [];
                    const categoryDetails = document.createElement('details'); // Nested collapsible for each sex category
                    categoryDetails.className = "mb-3 bg-gray-50 rounded-md shadow-xs";
                    // Preserve open state for this specific category's details
                    if (nestedOpenStates[level] && nestedOpenStates[level][sexCategory] !== undefined) {
                        categoryDetails.open = nestedOpenStates[level][sexCategory];
                    }
                    categoryDetails.setAttribute('data-level', level); // Add data-level for nested
                    categoryDetails.setAttribute('data-category', sexCategory); // Add data-category for nested

                    categoryDetails.innerHTML = `
                        <summary class="collapsible-header text-lg font-medium text-gray-600 capitalize">
                            ${sexCategory === 'neutral' ? 'Neutre' : sexCategory}
                            <svg class="w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                        </summary>
                        <div class="collapsible-content nested-collapsible-content space-y-2" id="bodyParts-${level}-${sexCategory}-content">
                            <!-- Content for parts will be rendered here -->
                        </div>
                    `;
                    const categoryContentDiv = categoryDetails.querySelector(`#bodyParts-${level}-${sexCategory}-content`);


                    if (categoryData && Array.isArray(categoryData)) {
                        if (categoryData.length > 0) {
                            hasContent = true;
                            categoryData.forEach((part, index) => {
                                const itemDiv = document.createElement('div');
                                itemDiv.className = "flex items-center gap-2 mb-2";
                                itemDiv.innerHTML = `
                                    <input type="text" value="${part}" data-level="${level}" data-category="${sexCategory}" data-index="${index}" class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-purple-400 outline-none bodypart-input" />
                                    <button class="bg-red-400 hover:bg-red-500 text-white p-2 rounded-full text-sm transition duration-200 remove-bodypart-btn" data-level="${level}" data-category="${sexCategory}" data-index="${index}">&times;</button>
                                `;
                                categoryContentDiv.appendChild(itemDiv);
                            });
                        }
                    } else {
                        // Ensure the category exists as an empty array if not already
                        if (!editableBodyParts[level]) editableBodyParts[level] = {};
                        editableBodyParts[level][sexCategory] = [];
                    }

                    const addBtn = document.createElement('button');
                    addBtn.className = "bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-full text-sm mt-3 transition duration-200";
                    addBtn.textContent = "Ajouter Zone";
                    addBtn.onclick = () => {
                        editableBodyParts[level][sexCategory].push('');
                        renderAdminBodyParts();
                    };
                    categoryContentDiv.appendChild(addBtn);
                    levelContentDiv.appendChild(categoryDetails); // Append the nested details element
                });
                bodyPartsEditorDiv.appendChild(levelDetails); // Append the main details element
            });

            if (!hasContent && Object.keys(editableBodyParts).length === 0) {
                bodyPartsEditorDiv.innerHTML = '<p class="text-red-500 text-center">Aucune donn√©e de zone du corps charg√©e. V√©rifiez la console pour les erreurs Firebase.</p>';
            }

            // Restore main details open state
            adminBodyPartsDetails.open = wasMainOpen;

            // Attach listeners AFTER all elements are in the DOM
            bodyPartsEditorDiv.querySelectorAll('.bodypart-input').forEach(input => {
                input.oninput = (e) => {
                    const level = e.target.dataset.level;
                    const category = e.target.dataset.category;
                    const index = parseInt(e.target.dataset.index);
                    editableBodyParts[level][category][index] = e.target.value;
                };
            });
            bodyPartsEditorDiv.querySelectorAll('.remove-bodypart-btn').forEach(button => {
                button.onclick = (e) => {
                    const level = e.target.dataset.level;
                    const category = e.target.dataset.category;
                    const index = parseInt(e.target.dataset.index);
                    editableBodyParts[level][category] = editableBodyParts[level][category].filter((_, i) => i !== index);
                    renderAdminBodyParts();
                };
            });
        }

        function renderAdminJokerChallenges() {
            console.log("DEBUG: renderAdminJokerChallenges called. editableJokerChallenges state:", editableJokerChallenges);
            // Capture current open state
            const wasOpen = adminJokerChallengesDetails.open;

            jokerChallengesEditorDiv.innerHTML = ''; // Clear existing content
            const orderedLevels = ['level1', 'level2', 'level3', 'level4', 'level5']; // Define order

            let hasContent = false;
            orderedLevels.forEach(level => {
                const levelData = editableJokerChallenges[level];
                const levelDetails = document.createElement('details'); // Main collapsible for each level
                levelDetails.className = "mb-6 p-4 border border-purple-200 rounded-lg bg-purple-50";
                // Preserve open state for this specific level's details
                const currentLevelDetailsElem = jokerChallengesEditorDiv.querySelector(`details[data-level="${level}"]`);
                if (currentLevelDetailsElem) {
                    levelDetails.open = currentLevelDetailsElem.open;
                }
                levelDetails.setAttribute('data-level', level); // Add data-level attribute

                levelDetails.innerHTML = `
                    <summary class="collapsible-header text-xl font-semibold text-purple-800 capitalize">
                        ${level}
                        <svg class="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                    </summary>
                    <div class="collapsible-content nested-collapsible-content space-y-4" id="joker-${level}-content">
                        <!-- Content for joker challenges will be rendered here -->
                    </div>
                `;
                const levelContentDiv = levelDetails.querySelector(`#joker-${level}-content`);

                if (levelData && Array.isArray(levelData)) {
                    if (levelData.length > 0) {
                        hasContent = true;
                        levelData.forEach((challenge, index) => {
                            const challengeDiv = document.createElement('div');
                            challengeDiv.className = "mb-4 p-3 border border-purple-100 rounded-lg bg-white shadow-sm";
                            challengeDiv.innerHTML = `
                                <div class="flex flex-col gap-2">
                                    <label class="block text-gray-700 text-sm font-bold mb-1">Template du d√©fi (utiliser {player1}, {player2}, {player3})</label>
                                    <textarea rows="3" data-level="${level}" data-index="${index}" data-field="template" class="p-2 border border-gray-300 rounded-lg w-full focus:ring-1 focus:ring-purple-400 outline-none joker-input" placeholder="Ex: {player1} doit embrasser {player2} sur {bodyPart}.">${challenge.template}</textarea>
                                    <label class="block text-gray-700 text-sm font-bold mb-1 mt-2">Joueurs n√©cessaires (1, 2, 3 ou 'all')</label>
                                    <select data-level="${level}" data-index="${index}" data-field="playersNeeded" class="p-2 border border-gray-300 rounded-lg w-full focus:ring-1 focus:ring-purple-400 outline-none joker-select">
                                        <option value="1" ${challenge.playersNeeded == 1 ? 'selected' : ''}>1</option>
                                        <option value="2" ${challenge.playersNeeded == 2 ? 'selected' : ''}>2</option>
                                        <option value="3" ${challenge.playersNeeded == 3 ? 'selected' : ''}>3</option>
                                        <option value="all" ${challenge.playersNeeded == 'all' ? 'selected' : ''}>Tous</option>
                                    </select>
                                    <label class="block text-gray-700 text-sm font-bold mb-1 mt-2">Accessoires (s√©par√©s par des virgules)</label>
                                    <input type="text" value="${challenge.accessories ? challenge.accessories.join(', ') : ''}" data-level="${level}" data-index="${index}" data-field="accessories" class="p-2 border border-gray-300 rounded-lg w-full focus:ring-1 focus:ring-purple-400 outline-none joker-input" placeholder="Ex: bandeau, gla√ßon" />
                                    <button class="bg-red-400 hover:bg-red-500 text-white p-2 rounded-full text-sm mt-3 transition duration-200 self-end remove-joker-btn" data-level="${level}" data-index="${index}">Supprimer ce d√©fi</button>
                                </div>
                            `;
                            levelContentDiv.appendChild(challengeDiv);
                        });
                    }
                } else {
                    console.warn(`DEBUG: editableJokerChallenges[${level}] est vide ou non un tableau.`);
                    editableJokerChallenges[level] = [];
                }

                const addBtn = document.createElement('button');
                addBtn.className = "bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-full text-sm mt-3 transition duration-200";
                addBtn.textContent = "Ajouter Nouveau D√©fi Joker";
                addBtn.onclick = () => {
                    const newId = `joker-${level}-${Date.now()}`;
                    editableJokerChallenges[level].push({ id: newId, template: '', playersNeeded: 1, accessories: [] });
                    renderAdminJokerChallenges();
                };
                levelContentDiv.appendChild(addBtn);
                jokerChallengesEditorDiv.appendChild(levelDetails); // Append the details element
            });

            if (!hasContent && Object.keys(editableJokerChallenges).length === 0) {
                jokerChallengesEditorDiv.innerHTML = '<p class="text-red-500 text-center">Aucune donn√©e de d√©fi Joker charg√©e. V√©rifiez la console pour les erreurs Firebase.</p>';
            }

            // Restore main details open state
            adminJokerChallengesDetails.open = wasOpen;

            // Attach listeners AFTER all elements are in the DOM
            jokerChallengesEditorDiv.querySelectorAll('.joker-input').forEach(input => {
                input.oninput = (e) => {
                    const level = e.target.dataset.level;
                    const index = parseInt(e.target.dataset.index);
                    const field = e.target.dataset.field;
                    if (field === 'accessories') {
                        editableJokerChallenges[level][index][field] = e.target.value.split(',').map(s => s.trim()).filter(s => s !== '');
                    } else {
                        editableJokerChallenges[level][index][field] = e.target.value;
                    }
                };
            });
            jokerChallengesEditorDiv.querySelectorAll('.joker-select').forEach(select => {
                select.onchange = (e) => {
                    const level = e.target.dataset.level;
                    const index = parseInt(e.target.dataset.index);
                    const field = e.target.dataset.field;
                    editableJokerChallenges[level][index][field] = isNaN(parseInt(e.target.value)) ? e.target.value : parseInt(e.target.value);
                };
            });
            jokerChallengesEditorDiv.querySelectorAll('.remove-joker-btn').forEach(button => {
                button.onclick = (e) => {
                    const level = e.target.dataset.level;
                    const index = parseInt(e.target.dataset.index);
                    editableJokerChallenges[level] = editableJokerChallenges[level].filter((_, i) => i !== index);
                    renderAdminJokerChallenges();
                };
            });
        }


        // Fonction de rendu principale qui met √† jour toute l'interface
        function renderUI() {
            console.log("DEBUG: renderUI called. showInstructions:", showInstructions);
            renderPlayersList();
            renderLevelSelect();
            updateTensionBar();
            updateReelsDisplay();
            // Admin UI is rendered conditionally
            if (isAdminMode) {
                showModal(adminModal); // Use showModal helper
                if (adminPassword === ADMIN_SECRET_PASSWORD) {
                    adminAuthSection.classList.add('hidden');
                    adminContent.classList.remove('hidden');
                    renderAdminActions();
                    renderAdminBodyParts();
                    renderAdminJokerChallenges();
                } else {
                    adminAuthSection.classList.remove('hidden');
                    adminContent.classList.add('hidden');
                }
            } else {
                hideModal(adminModal); // Use hideModal helper
            }

            // Update body background
            const currentBackgroundClass = backgroundGradients[currentLevelIndex];
            body.className = `min-h-screen bg-gradient-to-br ${currentBackgroundClass} flex flex-col items-center justify-center p-4 text-gray-800 pb-16 transition-all duration-1000 ease-in-out`;

            // Ensure instructions modal is shown if needed
            if (showInstructions) {
                showModal(instructionsModal);
            } else {
                hideModal(instructionsModal);
            }
        }

        // --- Fonctions de logique du jeu ---
        async function addPlayer() { // Made async
            const name = newPlayerNameInput.value.trim();
            if (name === '') {
                showMessageModal("Le nom du joueur ne peut pas √™tre vide !", 'error');
                return;
            }
            if (players.length >= 10) {
                showMessageModal("Vous ne pouvez pas ajouter plus de 10 joueurs.", 'error');
                return;
            }
            if (players.some(player => player.name.toLowerCase() === name.toLowerCase())) {
                showMessageModal(`Le joueur "${name}" existe d√©j√†.`, 'error');
                return;
            }

            const sex = document.querySelector('input[name="newPlayerSex"]:checked').value;
            const acceptSameSex = newPlayerAcceptSameSexCheckbox.checked;

            players.push({ name, sex, acceptSameSex });
            newPlayerNameInput.value = '';
            document.querySelector('input[name="newPlayerSex"][value="homme"]').checked = true;
            newPlayerAcceptSameSexCheckbox.checked = true;

            // R√©initialiser les compteurs de participation et le niveau
            const newCounts = {};
            players.forEach(player => {
                newCounts[player.name] = {};
                levelOrder.forEach(level => {
                    newCounts[player.name][level.id] = 0;
                });
            });
            playerParticipationCounts = newCounts;
            currentLevelIndex = 0;
            result = { player1: null, action: '', bodyPart: null, player2: null, countdownTime: 0, isJokerChallenge: false, jokerChallengeText: '' };
            remainingTime = 0;
            isCountingDown = false;
            if (countdownInterval) clearInterval(countdownInterval);
            level6Challenges = null;
            soloPlayersForLevel6 = [];
            await saveGameData(); // Save game data after adding player
            renderUI();
        }

        async function removePlayer(index) { // Made async
            players = players.filter((_, i) => i !== index);
            // R√©initialiser les compteurs de participation et le niveau
            const newCounts = {};
            players.forEach(player => {
                newCounts[player.name] = {};
                levelOrder.forEach(level => {
                    newCounts[player.name][level.id] = 0;
                });
            });
            playerParticipationCounts = newCounts;
            currentLevelIndex = 0;
            result = { player1: null, action: '', bodyPart: null, player2: null, countdownTime: 0, isJokerChallenge: false, jokerChallengeText: '' };
            remainingTime = 0;
            isCountingDown = false;
            if (countdownInterval) clearInterval(countdownInterval);
            level6Challenges = null;
            soloPlayersForLevel6 = [];
            await saveGameData(); // Save game data after removing player
            renderUI();
        }

        async function addTenPlayersAutomatically() { // Made async
            const maleNames = ["Alexandre", "Benjamin", "Charles", "Damien", "√âtienne", "Fran√ßois", "Guillaume", "Hugo", "Ivan", "Julien"];
            const femaleNames = ["Alice", "B√©atrice", "Camille", "Delphine", "√âmilie", "Fanny", "Gabrielle", "H√©l√®ne", "In√®s", "Jeanne"];
            const autoPlayers = [];

            const shuffledMaleNames = [...maleNames].sort(() => 0.5 - Math.random());
            const shuffledFemaleNames = [...femaleNames].sort(() => 0.5 - Math.random());

            for (let i = 0; i < 10; i++) {
                let name;
                let sex;
                if (i % 2 === 0) {
                    sex = 'homme';
                    name = shuffledMaleNames[Math.floor(i / 2)];
                } else {
                    sex = 'femme';
                    name = shuffledFemaleNames[Math.floor(i / 2)];
                }
                const acceptSameSex = i % 4 < 2;
                autoPlayers.push({ name, sex, acceptSameSex });
            }
            players = autoPlayers;

            const newCounts = {};
            players.forEach(player => {
                newCounts[player.name] = {};
                levelOrder.forEach(level => {
                    newCounts[player.name][level.id] = 0;
                });
            });
            playerParticipationCounts = newCounts;
            currentLevelIndex = 0;
            result = { player1: null, action: '', bodyPart: null, player2: null, countdownTime: 0, isJokerChallenge: false, jokerChallengeText: '' };
            remainingTime = 0;
            isCountingDown = false;
            if (countdownInterval) clearInterval(countdownInterval);
            level6Challenges = null;
            soloPlayersForLevel6 = [];
            await saveGameData(); // Save game data after adding players
            renderUI();
        }

        async function handleLevelChange(event) { // Made async
            const newIndex = parseInt(event.target.value, 10);
            const oldIndex = currentLevelIndex;

            result = { player1: null, action: '', bodyPart: null, player2: null, countdownTime: 0, isJokerChallenge: false, jokerChallengeText: '' };
            remainingTime = 0;
            isCountingDown = false;
            if (countdownInterval) clearInterval(countdownInterval);
            level6Challenges = null;
            soloPlayersForLevel6 = [];

            if (newIndex === 5) {
                if (players.length < 2) {
                    showMessageModal("Il faut au moins 2 joueurs pour g√©n√©rer les d√©fis du Niveau 6.", 'error');
                    levelSelect.value = oldIndex; // Revert selection
                    return;
                }
                const groupingResult = formLevel6Groups(players);
                if (groupingResult === null) {
                    // Error already shown by formLevel6Groups
                    levelSelect.value = oldIndex; // Revert selection
                    return;
                }
                level6Challenges = groupingResult.groups;
                soloPlayersForLevel6 = groupingResult.soloPlayers;
                result.countdownTime = (Math.floor(Math.random() * 12) + 1) * 5;
            }

            currentLevelIndex = newIndex;

            const newCounts = {};
            players.forEach(player => {
                newCounts[player.name] = {};
                levelOrder.forEach(level => {
                    newCounts[player.name][level.id] = 0;
                });
            });
            playerParticipationCounts = newCounts;
            await saveGameData(); // Save game data after level change
            renderUI();
        }

        function formLevel6Groups(currentPlayersToGroup) {
            if (currentPlayersToGroup.length < 2) {
                showMessageModal("Il faut au moins 2 joueurs pour former des groupes au Niveau 6.", 'error');
                return null;
            }

            const shuffledPlayers = [...currentPlayersToGroup].sort(() => 0.5 - Math.random());
            const groups = [];
            const remainingPlayers = [...shuffledPlayers];
            const soloPlayers = [];

            const getRandomFusionAction = () => actionsData.fusion[Math.floor(Math.random() * actionsData.fusion.length)];
            const getRandomIntenseBodyPart = () => {
                const allIntenseParts = [
                    ...(bodyPartsData.intense?.neutral || []),
                    ...(bodyPartsData.intense?.femme || []) // Exclut sp√©cifiquement les parties "homme"
                ];
                // Filtrer pour s'assurer qu'aucune partie masculine ne se retrouve par erreur
                const filteredParts = allIntenseParts.filter(part => !['le p√©nis', 'le gland', 'le scrotum'].includes(part));
                return filteredParts[Math.floor(Math.random() * filteredParts.length)];
            };

            let attempts = 0;
            const maxPairingAttempts = remainingPlayers.length * remainingPlayers.length;

            while (remainingPlayers.length >= 2 && attempts < maxPairingAttempts) {
                let p1Index = -1;
                let p2Index = -1;

                for (let i = 0; i < remainingPlayers.length; i++) {
                    for (let j = i + 1; j < remainingPlayers.length; j++) {
                        if (remainingPlayers[i].sex !== remainingPlayers[j].sex && checkCompatibility(remainingPlayers[i], remainingPlayers[j])) {
                            p1Index = i;
                            p2Index = j;
                            break;
                        }
                    }
                    if (p1Index !== -1) break;
                }

                if (p1Index !== -1) {
                    const selectedBodyPart = getRandomIntenseBodyPart();
                    groups.push({ players: [remainingPlayers[p1Index], remainingPlayers[p2Index]], challenge: `${getRandomFusionAction()}. Le d√©fi se termine par une √©jaculation sur ${selectedBodyPart}.` });
                    remainingPlayers.splice(p2Index, 1);
                    remainingPlayers.splice(p1Index, 1);
                    attempts = 0;
                } else {
                    p1Index = -1;
                    p2Index = -1;
                    for (let i = 0; i < remainingPlayers.length; i++) {
                        for (let j = i + 1; j < remainingPlayers.length; j++) {
                            if (checkCompatibility(remainingPlayers[i], remainingPlayers[j])) {
                                p1Index = i;
                                p2Index = j;
                                break;
                            }
                        }
                        if (p1Index !== -1) break;
                    }

                    if (p1Index !== -1) {
                        const selectedBodyPart = getRandomIntenseBodyPart();
                        groups.push({ players: [remainingPlayers[p1Index], remainingPlayers[p2Index]], challenge: `${getRandomFusionAction()}. Le d√©fi se termine par une √©jaculation sur ${selectedBodyPart}.` });
                        remainingPlayers.splice(p2Index, 1);
                        remainingPlayers.splice(p1Index, 1);
                        attempts = 0;
                    } else {
                        attempts++;
                    }
                }
            }

            if (remainingPlayers.length === 3) {
                const trio = remainingPlayers;
                let trioValid = true;
                if (!checkCompatibility(trio[0], trio[1]) || !checkCompatibility(trio[0], trio[2]) || !checkCompatibility(trio[1], trio[2])) {
                    trioValid = false;
                }

                if (trioValid) {
                    const selectedBodyPart = getRandomIntenseBodyPart();
                    groups.push({ players: trio, challenge: `${getRandomFusionAction()}. Le d√©fi se termine par une √©jaculation sur ${selectedBodyPart}.` });
                    remainingPlayers.length = 0;
                } else {
                    trio.forEach(p => soloPlayers.push(p));
                    remainingPlayers.length = 0;
                }
            }

            remainingPlayers.forEach(p => soloPlayers.push(p));

            return { groups, soloPlayers };
        }

        function generateUndressingMessages(playersList, actionVerb, targetAdverb) {
            if (playersList.length === 0) {
                return "Il n'y a pas de joueurs pour se d√©shabiller !";
            }

            const messages = [];
            const targetsToUndress = [...playersList];
            const undressers = [...playersList];

            const assignments = new Map();

            for (let i = 0; i < targetsToUndress.length; i++) {
                const target = targetsToUndress[i];
                let foundAssignment = false;
                const shuffledUndressers = [...undressers].sort(() => 0.5 - Math.random());

                for (const undresserCandidate of shuffledUndressers) {
                    if (undresserCandidate.name === target.name) {
                        continue;
                    }
                    if (checkCompatibility(undresserCandidate, target)) {
                        assignments.set(target.name, undresserCandidate);
                        foundAssignment = true;
                        break;
                    }
                }

                if (!foundAssignment) {
                    showMessageModal(`Impossible de trouver une personne compatible pour d√©shabiller ${target.name}. Veuillez ajuster les pr√©f√©rences des joueurs.`, 'error');
                    return null;
                }
            }

            for (const player of playersList) {
                const undresser = assignments.get(player.name);
                if (undresser) {
                    messages.push(`${getColoredName(undresser)} ${actionVerb} ${targetAdverb} ${getColoredName(player)}.`);
                }
            }
            return messages.join('<br/>');
        }

        function startCountdown() {
            if (result.countdownTime === 0 || isCountingDown) return;

            isCountingDown = true;
            remainingTime = result.countdownTime;
            renderUI(); // Update UI to show countdown started

            countdownInterval = setInterval(() => {
                remainingTime--;
                if (remainingTime <= 0) {
                    clearInterval(countdownInterval);
                    isCountingDown = false;
                    remainingTime = 0;
                }
                renderUI(); // Update UI every second
            }, 1000);
        }

        async function spinWheel() {
            if (players.length < 2) {
                showMessageModal("Il faut au moins 2 joueurs pour lancer le jeu !", 'error');
                return;
            }

            remainingTime = 0;
            isCountingDown = false;
            if (countdownInterval) clearInterval(countdownInterval);

            const isJoker = currentLevelIndex < 5 && Math.random() < 0.25;

            isSpinning = true;
            result = { player1: null, action: '', bodyPart: null, player2: null, countdownTime: 0, isJokerChallenge: false, jokerChallengeText: '' };
            renderUI(); // Show spinning state (buttons disabled)

            // Define options for each reel based on current state
            const playerOptions = players.map(p => p.name);
            const currentLevel = levelOrder[currentLevelIndex];
            const actionOptions = actionsData[currentLevel.actionType] || [];
            const bodyPartOptionsNeutral = bodyPartsData[currentLevel.bodyPartType].neutral || [];
            const bodyPartOptionsHomme = bodyPartsData[currentLevel.bodyPartType].homme || [];
            const bodyPartOptionsFemme = bodyPartsData[currentLevel.bodyPartType].femme || [];
            const allBodyPartOptions = [...bodyPartOptionsNeutral, ...bodyPartOptionsHomme, ...bodyPartOptionsFemme];

            const jokerLetters = ['J', 'O', 'K', 'E', 'R'];

            const spinDuration = 2000; // Base spin duration
            const stopDelayIncrement = 300; // Delay between stopping each reel

            // Start spinning each reel and add spinning class
            if (currentLevelIndex < 5) {
                player1SpinInterval = startReelSpin(player1ReelContent, isJoker ? jokerLetters : playerOptions);
                actionSpinInterval = startReelSpin(actionReelContent, isJoker ? jokerLetters : actionOptions);
                bodyPartSpinInterval = startReelSpin(bodyPartReelContent, isJoker ? jokerLetters : allBodyPartOptions);
                player2SpinInterval = startReelSpin(player2ReelContent, isJoker ? jokerLetters : playerOptions);
                countdownSpinInterval = startReelSpin(countdownReelContent, isJoker ? jokerLetters : countdownOptions);

                player1ReelContainer.classList.add('spinning');
                actionReelContainer.classList.add('spinning');
                bodyPartReelContainer.classList.add('spinning');
                player2ReelContainer.classList.add('spinning');
                countdownReelContainer.classList.add('spinning');

                // Determine the final result logic
                if (isJoker) {
                    const currentLevelJokerChallenges = getJokerChallengesForLevel(`level${currentLevelIndex + 1}`);
                    if (!currentLevelJokerChallenges || currentLevelJokerChallenges.length === 0) {
                        showMessageModal("Aucun d√©fi Joker disponible pour ce niveau.", 'error');
                        // Immediately stop and reset if error
                        stopReelSpin(player1SpinInterval, player1ReelContent, '???');
                        stopReelSpin(actionSpinInterval, actionReelContent, '???');
                        stopReelSpin(bodyPartSpinInterval, bodyPartReelContent, '???');
                        stopReelSpin(player2SpinInterval, player2ReelContent, '???');
                        stopReelSpin(countdownSpinInterval, countdownReelContent, '???');
                        isSpinning = false;
                        player1ReelContainer.classList.remove('spinning');
                        actionReelContainer.classList.remove('spinning');
                        bodyPartReelContainer.classList.remove('spinning');
                        player2ReelContainer.classList.remove('spinning');
                        countdownReelContainer.classList.remove('spinning');
                        renderUI();
                        return;
                    }
                    const selectedJokerChallengeDef = currentLevelJokerChallenges[Math.floor(Math.random() * currentLevelJokerChallenges.length)];
                    const generatedJokerText = generateJokerChallengeText(selectedJokerChallengeDef);

                    result.isJokerChallenge = true;
                    result.jokerChallengeText = generatedJokerText;
                    result.countdownTime = (Math.floor(Math.random() * 12) + 1) * 5;

                    // Schedule individual reel stops
                    setTimeout(() => stopReelSpin(player1SpinInterval, player1ReelContent, 'J'), spinDuration);
                    setTimeout(() => stopReelSpin(actionSpinInterval, actionReelContent, 'O'), spinDuration + stopDelayIncrement);
                    setTimeout(() => stopReelSpin(bodyPartSpinInterval, bodyPartReelContent, 'K'), spinDuration + 2 * stopDelayIncrement);
                    setTimeout(() => stopReelSpin(player2SpinInterval, player2ReelContent, 'E'), spinDuration + 3 * stopDelayIncrement);
                    setTimeout(() => stopReelSpin(countdownSpinInterval, countdownReelContent, 'R'), spinDuration + 4 * stopDelayIncrement);

                } else { // Regular spin logic
                    const currentActions = actionsData[currentLevel.actionType];
                    const currentBodyPartsNeutral = bodyPartsData[currentLevel.bodyPartType].neutral;
                    const currentBodyPartsHomme = bodyPartsData[currentLevel.bodyPartType].homme;
                    const currentBodyPartsFemme = bodyPartsData[currentLevel.bodyPartType].femme;

                    if (!currentActions || currentActions.length === 0) {
                        showMessageModal(`Aucune action disponible pour le niveau d'intensit√© "${currentLevel.name}".`, 'error');
                        // Immediately stop and reset if error
                        stopReelSpin(player1SpinInterval, player1ReelContent, '???');
                        stopReelSpin(actionSpinInterval, actionReelContent, '???');
                        stopReelSpin(bodyPartSpinInterval, bodyPartReelContent, '???');
                        stopReelSpin(player2SpinInterval, player2ReelContent, '???');
                        stopReelSpin(countdownSpinInterval, countdownReelContent, '???');
                        isSpinning = false;
                        player1ReelContainer.classList.remove('spinning');
                        actionReelContainer.classList.remove('spinning');
                        bodyPartReelContainer.classList.remove('spinning');
                        player2ReelContainer.classList.remove('spinning');
                        countdownReelContainer.classList.remove('spinning');
                        renderUI();
                        return;
                    }

                    let p1Obj, p2Obj, act, bp;
                    let isValidCombination = false;
                    let attempts = 0;
                    const maxAttempts = 100;

                    do {
                        p1Obj = players[Math.floor(Math.random() * players.length)];
                        p2Obj = players[Math.floor(Math.random() * players.length)];

                        if (p1Obj.name === p2Obj.name) { attempts++; continue; }
                        if (!checkCompatibility(p1Obj, p2Obj)) { attempts++; continue; }

                        act = currentActions[Math.floor(Math.random() * currentActions.length)];

                        let availableBodyParts = [...currentBodyPartsNeutral];
                        if (p2Obj.sex === 'homme') { availableBodyParts = availableBodyParts.concat(currentBodyPartsHomme); }
                        else if (p2Obj.sex === 'femme') { availableBodyParts = availableBodyParts.concat(currentBodyPartsFemme); }

                        if (availableBodyParts.length === 0) { attempts++; continue; }

                        bp = availableBodyParts[Math.floor(Math.random() * availableBodyParts.length)];
                        isValidCombination = true;

                    } while (!isValidCombination && attempts < maxAttempts);

                    if (!isValidCombination) {
                        showMessageModal("Impossible de trouver une combinaison valide avec les joueurs et pr√©f√©rences actuels. Essayez de modifier les joueurs ou les pr√©f√©rences.", 'error');
                        // Immediately stop and reset if error
                        stopReelSpin(player1SpinInterval, player1ReelContent, '???');
                        stopReelSpin(actionSpinInterval, actionReelContent, '???');
                        stopReelSpin(bodyPartSpinInterval, bodyPartReelContent, '???');
                        stopReelSpin(player2SpinInterval, player2ReelContent, '???');
                        stopReelSpin(countdownSpinInterval, countdownReelContent, '???');
                        isSpinning = false;
                        player1ReelContainer.classList.remove('spinning');
                        actionReelContainer.classList.remove('spinning');
                        bodyPartReelContainer.classList.remove('spinning');
                        player2ReelContainer.classList.remove('spinning');
                        countdownReelContainer.classList.remove('spinning');
                        renderUI();
                        return;
                    }

                    const randomTime = (Math.floor(Math.random() * 12) + 1) * 5;
                    result = { player1: p1Obj, action: act, bodyPart: bp, player2: p2Obj, countdownTime: randomTime, isJokerChallenge: false, jokerChallengeText: '' };

                    // Schedule individual reel stops
                    setTimeout(() => stopReelSpin(player1SpinInterval, player1ReelContent, result.player1.name, result.player1.sex === 'homme' ? 'text-blue-600' : 'text-pink-600'), spinDuration);
                    setTimeout(() => stopReelSpin(actionSpinInterval, actionReelContent, result.action), spinDuration + stopDelayIncrement);
                    setTimeout(() => stopReelSpin(bodyPartSpinInterval, bodyPartReelContent, result.bodyPart), spinDuration + 2 * stopDelayIncrement);
                    setTimeout(() => stopReelSpin(player2SpinInterval, player2ReelContent, result.player2.name, result.player2.sex === 'homme' ? 'text-blue-600' : 'text-pink-600'), spinDuration + 3 * stopDelayIncrement);
                    setTimeout(() => stopReelSpin(countdownSpinInterval, countdownReelContent, `${result.countdownTime}s`), spinDuration + 4 * stopDelayIncrement);
                }

                // This is the *final* cleanup and UI update, guaranteed to run after all individual reel stops are scheduled.
                // It should run after the longest scheduled stop.
                setTimeout(async () => {
                    isSpinning = false; // Finally, set spinning to false
                    // Remove spinning classes
                    player1ReelContainer.classList.remove('spinning');
                    actionReelContainer.classList.remove('spinning');
                    bodyPartReelContainer.classList.remove('spinning');
                    player2ReelContainer.classList.remove('spinning');
                    countdownReelContainer.classList.remove('spinning');

                    // Update participation counts and check for level up
                    const currentLevelId = levelOrder[currentLevelIndex].id;
                    if (result.player1 && result.player2) { // Update counts only if it's a regular spin
                        if (!playerParticipationCounts[result.player1.name]) playerParticipationCounts[result.player1.name] = {};
                        if (!playerParticipationCounts[result.player2.name]) playerParticipationCounts[result.player2.name] = {};

                        if (!playerParticipationCounts[result.player1.name][currentLevelId]) playerParticipationCounts[result.player1.name][currentLevelId] = 0;
                        if (!playerParticipationCounts[result.player2.name][currentLevelId]) playerParticipationCounts[result.player2.name][currentLevelId] = 0;

                        playerParticipationCounts[result.player1.name][currentLevelId]++;
                        playerParticipationCounts[result.player2.name][currentLevelId]++;
                    }

                    let shouldAdvance = false;
                    for (const player of players) {
                        if (playerParticipationCounts[player.name] && playerParticipationCounts[player.name][currentLevelId] >= 5) {
                            shouldAdvance = true;
                            break;
                        }
                    }

                    if (shouldAdvance && currentLevelIndex < 5) { // Avancer uniquement si pas d√©j√† au niveau max
                        const nextLevelIndex = currentLevelIndex + 1;
                        let title = '';
                        let message = '';
                        let showModalFlag = false;

                        if (nextLevelIndex === 5) {
                            const groupingResult = formLevel6Groups(players);
                            if (groupingResult === null) {
                                renderUI();
                                return;
                            }
                            level6Challenges = groupingResult.groups;
                            soloPlayersForLevel6 = groupingResult.soloPlayers;
                            title = "Niveau 5 Termin√© : Fusion Ultime !";
                            message = "Incroyable ! Le niveau 5 est termin√© ! Pr√©parez-vous pour des d√©fis en duo/trio. Chaque groupe devra s'adonner √† une action intime jusqu'√† ce que vous atteigniez un √©tat de profonde intimit√©. Laissez libre cours √† votre connexion ! üî•";
                            showModalFlag = true;
                            result.countdownTime = (Math.floor(Math.random() * 12) + 1) * 5; // D√©finir le temps pour le Niveau 6
                        } else if (currentLevelId === 'level2') {
                            title = "Niveau 2 Termin√© : En sous-v√™tements !";
                            const undressingMessages = generateUndressingMessages(players, 'd√©shabille', 'en sous-v√™tement');
                            if (undressingMessages === null) {
                                renderUI();
                                return;
                            }
                            message = `F√©licitations, le niveau 2 est termin√© ! Il est temps de passer au niveau 3.<br/><br/>${undressingMessages}<br/><br/>Tout le monde doit maintenant √™tre en sous-v√™tements. üòâ`;
                            showModalFlag = true;
                        } else if (currentLevelId === 'level4') {
                            title = "Niveau 4 Termin√© : Compl√®tement nus !";
                            const undressingMessages = generateUndressingMessages(players, 'd√©shabille', 'compl√®tement');
                            if (undressingMessages === null) {
                                renderUI();
                                return;
                            }
                            message = `Bravo, le niveau 4 est termin√© ! Pr√©parez-vous pour le niveau 5.<br/><br/>${undressingMessages}<br/><br/>Tout le monde doit maintenant √™tre compl√®tement nu ! üòà`;
                            showModalFlag = true;
                        }

                        if (showModalFlag) {
                            levelUpTitle = title;
                            levelUpMessage = message;
                            levelUpTitleElem.innerHTML = levelUpTitle;
                            levelUpMessageElem.innerHTML = levelUpMessage;
                            showModal(levelUpModal);
                        }

                        for (const player of players) {
                            if (playerParticipationCounts[player.name]) {
                                playerParticipationCounts[player.name][currentLevelId] = 0;
                            }
                        }
                        currentLevelIndex = nextLevelIndex;
                        result = { player1: null, action: '', bodyPart: null, player2: null, countdownTime: 0, isJokerChallenge: false, jokerChallengeText: '' }; // Effacer le r√©sultat pour le passage de niveau
                        await saveGameData(); // Save game data after level up
                        renderUI();
                    } else {
                        // Si pas de passage de niveau, juste mettre √† jour l'UI avec le r√©sultat du spin actuel
                        await saveGameData(); // Save game data after spin
                        renderUI();
                    }
                }, spinDuration + 4 * stopDelayIncrement + 100); // Temps total pour que tous les rouleaux s'arr√™tent + petit tampon

            } else if (currentLevelIndex === 5) { // Logique pour le Niveau 6
                const randomTime = (Math.floor(Math.random() * 12) + 1) * 5;
                result.countdownTime = randomTime;
                result.isJokerChallenge = false;
                isSpinning = false;
                // Remove spinning classes (not applicable for Level 6, but good for consistency)
                player1ReelContainer.classList.remove('spinning');
                actionReelContainer.classList.remove('spinning');
                bodyPartReelContainer.classList.remove('spinning');
                player2ReelContainer.classList.remove('spinning');
                countdownReelContainer.classList.remove('spinning');
                await saveGameData(); // Save game data after spin
                renderUI();
            }
        }

        async function changeJokerChallenge() { // Made async
            if (isSpinning || !result.isJokerChallenge) return;

            if (countdownInterval) {
                clearInterval(countdownInterval);
                isCountingDown = false;
                remainingTime = 0;
            }

            const currentLevelJokerChallenges = getJokerChallengesForLevel(`level${currentLevelIndex + 1}`);
            if (!currentLevelJokerChallenges || currentLevelJokerChallenges.length === 0) {
                showMessageModal("Aucun autre d√©fi Joker disponible pour ce niveau.", 'error');
                return;
            }

            let newSelectedJokerChallengeDef;
            let newGeneratedJokerText;
            let attempts = 0;
            const maxAttempts = 100;

            do {
                newSelectedJokerChallengeDef = currentLevelJokerChallenges[Math.floor(Math.random() * currentLevelJokerChallenges.length)];
                newGeneratedJokerText = generateJokerChallengeText(newSelectedJokerChallengeDef);
                attempts++;
            } while (newGeneratedJokerText === result.jokerChallengeText && attempts < maxAttempts);

            if (attempts >= maxAttempts && newGeneratedJokerText === result.jokerChallengeText && currentLevelJokerChallenges.length > 1) {
                 newSelectedJokerChallengeDef = currentLevelJokerChallenges[Math.floor(Math.random() * currentLevelJokerChallenges.length)];
                 newGeneratedJokerText = generateJokerChallengeText(newSelectedJokerChallengeDef);
            }

            result.jokerChallengeText = newGeneratedJokerText;
            result.countdownTime = (Math.floor(Math.random() * 12) + 1) * 5;
            await saveGameData(); // Save game data after changing joker challenge
            renderUI();
        }

        /**
         * Re-spins a single reel based on its type.
         * This function handles the logic for clicking on an individual reel to re-roll it.
         * @param {string} reelType - The type of reel to re-spin ('player1', 'action', 'bodyPart', 'player2', 'countdown').
         */
        async function reSpinReel(reelType) {
            // Prevent re-spinning if a full spin is in progress, a countdown is active, it's a Joker challenge, or at Level 6
            if (isSpinning || isCountingDown || result.isJokerChallenge || currentLevelIndex === 5) {
                if (isSpinning) showMessageModal("Un tirage est d√©j√† en cours ! Veuillez attendre qu'il se termine.", 'error', true);
                else if (isCountingDown) showMessageModal("Un compte √† rebours est en cours ! Veuillez attendre qu'il se termine.", 'error', true);
                else if (result.isJokerChallenge) showMessageModal("Vous ne pouvez pas relancer les rouleaux individuellement pendant un d√©fi Joker.", 'error', true);
                else if (currentLevelIndex === 5) showMessageModal("La relance individuelle n'est pas disponible au Niveau 6.", 'error', true);
                return;
            }

            // Ensure a result exists before allowing individual reel re-spin
            if (!result.player1 && !result.action && !result.bodyPart && !result.player2 && !result.countdownTime) {
                showMessageModal("Veuillez d'abord lancer un tirage complet avant de relancer un rouleau individuel.", 'error', true);
                return;
            }

            isSpinning = true; // Temporarily set to true to disable main spin button and other individual re-spins
            spinWheelBtn.disabled = true; // Explicitly disable main spin button
            startCountdownBtn.disabled = true; // Disable countdown button during re-spin
            changeJokerChallengeBtn.disabled = true; // Disable joker button during re-spin

            const currentLevel = levelOrder[currentLevelIndex];
            let reelContentElement;
            let options;
            let finalValue;
            let textColorClass = 'text-purple-800'; // Default color for action/body part/countdown

            switch (reelType) {
                case 'player1':
                    reelContentElement = player1ReelContent;
                    options = players.map(p => p.name);
                    if (options.length === 0) { showMessageModal("Pas de joueurs √† s√©lectionner !", 'error', true); isSpinning = false; renderUI(); return; }
                    const newPlayer1 = players[Math.floor(Math.random() * players.length)];
                    result.player1 = newPlayer1;
                    finalValue = newPlayer1.name;
                    textColorClass = newPlayer1.sex === 'homme' ? 'text-blue-600' : 'text-pink-600';
                    break;
                case 'action':
                    reelContentElement = actionReelContent;
                    options = actionsData[currentLevel.actionType] || [];
                    if (options.length === 0) { showMessageModal(`Aucune action disponible pour le niveau "${currentLevel.name}".`, 'error', true); isSpinning = false; renderUI(); return; }
                    result.action = options[Math.floor(Math.random() * options.length)];
                    finalValue = result.action;
                    break;
                case 'bodyPart':
                    reelContentElement = bodyPartReelContent;
                    const currentBodyPartsNeutral = bodyPartsData[currentLevel.bodyPartType].neutral || [];
                    const currentBodyPartsHomme = bodyPartsData[currentLevel.bodyPartType].homme || [];
                    const currentBodyPartsFemme = bodyPartsData[currentLevel.bodyPartType].femme || [];
                    options = [...currentBodyPartsNeutral];
                    if (result.player2?.sex === 'homme') { options = options.concat(currentBodyPartsHomme); }
                    else if (result.player2?.sex === 'femme') { options = options.concat(currentBodyPartsFemme); }
                    if (options.length === 0) {
                        showMessageModal(`Aucune zone du corps disponible pour le niveau "${currentLevel.name}" ou le sexe du joueur 2.`, 'error', true);
                        isSpinning = false;
                        renderUI();
                        return;
                    }
                    result.bodyPart = options[Math.floor(Math.random() * options.length)];
                    finalValue = result.bodyPart;
                    break;
                case 'player2':
                    reelContentElement = player2ReelContent;
                    // Filter out player1 from options for player2
                    options = players.filter(p => p.name !== result.player1?.name).map(p => p.name);
                    if (options.length === 0) { showMessageModal("Pas assez de joueurs pour s√©lectionner un joueur 2 diff√©rent du joueur 1.", 'error', true); isSpinning = false; renderUI(); return; }
                    
                    let newPlayer2Candidate;
                    let attempts = 0;
                    const maxAttempts = 50; // Limit attempts to avoid infinite loops if no compatible player is found
                    do {
                        newPlayer2Candidate = players.filter(p => p.name !== result.player1?.name)[Math.floor(Math.random() * (players.length - 1))];
                        attempts++;
                    } while (newPlayer2Candidate && !checkCompatibility(result.player1, newPlayer2Candidate) && attempts < maxAttempts);

                    if (!newPlayer2Candidate || !checkCompatibility(result.player1, newPlayer2Candidate)) {
                        showMessageModal("Impossible de trouver un joueur 2 compatible avec le joueur 1. Veuillez ajuster les pr√©f√©rences des joueurs.", 'error', true);
                        isSpinning = false;
                        renderUI();
                        return;
                    }
                    result.player2 = newPlayer2Candidate;
                    finalValue = newPlayer2Candidate.name;
                    textColorClass = newPlayer2Candidate.sex === 'homme' ? 'text-blue-600' : 'text-pink-600';
                    break;
                case 'countdown':
                    reelContentElement = countdownReelContent;
                    options = countdownOptions;
                    result.countdownTime = (Math.floor(Math.random() * 12) + 1) * 5;
                    finalValue = `${result.countdownTime}s`;
                    break;
                default:
                    isSpinning = false;
                    renderUI();
                    return;
            }

            // Add spinning class to the specific reel container
            reelContentElement.parentElement.classList.add('spinning');
            const intervalId = startReelSpin(reelContentElement, options);

            setTimeout(async () => { // Made async to await saveGameData
                stopReelSpin(intervalId, reelContentElement, finalValue, textColorClass);
                reelContentElement.parentElement.classList.remove('spinning'); // Remove spinning class

                // After re-spinning one reel, we need to re-check compatibility for player1/player2
                // and ensure the overall result phrase is updated.
                if (result.player1 && result.player2 && !checkCompatibility(result.player1, result.player2)) {
                    // If re-spinning one player makes the pair incompatible, clear the result and show an error
                    result = { player1: null, action: '', bodyPart: '', player2: null, countdownTime: 0, isJokerChallenge: false, jokerChallengeText: '' };
                    showMessageModal("La nouvelle combinaison de joueurs est incompatible. Veuillez relancer le tirage complet ou ajuster les pr√©f√©rences.", 'error', true);
                }

                isSpinning = false; // Allow main spin button again
                await saveGameData(); // Save updated result
                renderUI(); // Re-render the UI to show the new combination and button states
            }, 1500); // Shorter duration for individual reel spin
        }


        // --- Firebase Functions ---
        async function saveGameData() {
            if (!db || !userId) {
                console.warn("Firestore DB ou User ID non pr√™t. Impossible de sauvegarder les donn√©es du jeu.");
                return;
            }
            try {
                // Correction du chemin pour le document gameData
                const gameDataRef = doc(db, 'artifacts', appId, 'users', userId, 'userGameData', 'main');
                await setDoc(gameDataRef, {
                    players: JSON.stringify(players), // Serialize array of objects
                    currentLevelIndex: currentLevelIndex,
                    playerParticipationCounts: JSON.stringify(playerParticipationCounts), // Serialize object of objects
                    // Save the current result state as well
                    currentResult: JSON.stringify(result)
                });
                console.log("Donn√©es du jeu sauvegard√©es avec succ√®s !");
            } catch (error) {
                console.error("Erreur lors de la sauvegarde des donn√©es du jeu :", error);
                showMessageModal("Erreur lors de la sauvegarde du jeu : " + error.message, 'error');
            }
        }

        async function loadGameData() {
            if (!db || !userId) {
                console.warn("Firestore DB ou User ID non pr√™t. Impossible de charger les donn√©es du jeu.");
                return;
            }
            try {
                // Correction du chemin pour le document gameData
                const gameDataRef = doc(db, 'artifacts', appId, 'users', userId, 'userGameData', 'main');
                const docSnap = await getDoc(gameDataRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    players = JSON.parse(data.players || '[]'); // Deserialize
                    currentLevelIndex = data.currentLevelIndex || 0;
                    playerParticipationCounts = JSON.parse(data.playerParticipationCounts || '{}'); // Deserialize
                    result = JSON.parse(data.currentResult || '{}'); // Load current result
                    console.log("Donn√©es du jeu charg√©es avec succ√®s !");
                } else {
                    console.log("Aucune donn√©e de jeu trouv√©e. D√©marrage d'un nouveau jeu.");
                    // Initialize default counts for existing players if any
                    const newCounts = {};
                    players.forEach(player => {
                        newCounts[player.name] = {};
                        levelOrder.forEach(level => {
                            newCounts[player.name][level.id] = 0;
                        });
                    });
                    playerParticipationCounts = newCounts;
                }
            } catch (error) {
                console.error("Erreur lors du chargement des donn√©es du jeu :", error);
                showMessageModal("Erreur lors du chargement du jeu : " + error.message, 'error');
            }
        }

        async function saveActionsData() {
            if (!db || !userId) { showMessageModal("Firebase non connect√©.", 'error'); return; }
            try {
                // Chemin standardis√© pour les donn√©es publiques des actions
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'gameData', 'actions');
                await setDoc(docRef, editableActions);
                actionsData = JSON.parse(JSON.stringify(editableActions)); // Update live data
                showMessageModal('Actions sauvegard√©es avec succ√®s !', 'success', true);
            } catch (e) {
                console.error("Error saving actions data: ", e);
                showMessageModal("Erreur de sauvegarde des actions : " + e.message, 'error');
            }
        }

        async function saveBodyPartsData() {
            if (!db || !userId) { showMessageModal("Firebase non connect√©.", 'error'); return; }
            try {
                // Chemin standardis√© pour les donn√©es publiques des parties du corps
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'gameData', 'bodyParts');
                await setDoc(docRef, editableBodyParts);
                bodyPartsData = JSON.parse(JSON.stringify(editableBodyParts)); // Update live data
                showMessageModal('Zones du corps sauvegard√©es avec succ√®s !', 'success', true);
            } catch (e) {
                console.error("Error saving body parts data: ", e);
                showMessageModal("Erreur de sauvegarde des zones du corps : " + e.message, 'error');
            }
        }

        async function saveJokerChallengesData() {
            if (!db || !userId) { showMessageModal("Firebase non connect√©.", 'error'); return; }
            try {
                // Chemin standardis√© pour les donn√©es publiques des d√©fis Joker
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'gameData', 'jokerChallenges');
                await setDoc(docRef, editableJokerChallenges);
                jokerChallengesTemplates = JSON.parse(JSON.stringify(editableJokerChallenges)); // Update live data
                showMessageModal('D√©fis Joker sauvegard√©s avec succ√®s !', 'success', true);
            } catch (e) {
                console.error("Error saving joker challenges data: ", e);
                showMessageModal("Erreur de sauvegarde des d√©fis Joker : " + e.message, 'error');
            }
        }

        async function initializeFirebaseAndLoadData() {
            console.log("DEBUG: Starting Firebase initialization and data loading...");
            // V√©rifie si la configuration Firebase est pr√©sente
            if (!firebaseConfig || !firebaseConfig.projectId) {
                showMessageModal("La configuration Firebase est manquante. Veuillez la coller dans le code.", 'error');
                // Fallback to default data if Firebase config is missing
                actionsData = JSON.parse(JSON.stringify(defaultActionsData));
                bodyPartsData = JSON.parse(JSON.stringify(defaultBodyPartsData));
                jokerChallengesTemplates = JSON.parse(JSON.stringify(defaultJokerChallengesTemplates));
                editableActions = JSON.parse(JSON.stringify(actionsData));
                editableBodyParts = JSON.parse(JSON.stringify(bodyPartsData));
                editableJokerChallenges = JSON.parse(JSON.stringify(jokerChallengesTemplates));
                console.log("DEBUG: Firebase config missing, using default data.");
                renderUI();
                return;
            }

            try {
                // Initialize Firebase app
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                console.log("DEBUG: Firebase app, db, auth initialized.");

                // Use onAuthStateChanged to ensure authentication is ready
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("DEBUG: User authenticated. User ID:", userId);
                        // Now that we are authenticated, proceed to load data
                        await loadGameData(); // Load user-specific game data
                        await loadPublicGameData(); // Load public admin data
                        renderUI(); // Initial render after all data is loaded
                    } else {
                        console.log("DEBUG: No user authenticated, attempting anonymous sign-in.");
                        try {
                            await signInAnonymously(auth);
                            // onAuthStateChanged will fire again with the anonymous user
                        } catch (anonError) {
                            console.error("DEBUG: Anonymous sign-in failed:", anonError);
                            showMessageModal("√âchec de la connexion anonyme √† Firebase : " + anonError.message, 'error');
                            // Fallback to default data if authentication fails
                            actionsData = JSON.parse(JSON.stringify(defaultActionsData));
                            bodyPartsData = JSON.parse(JSON.stringify(defaultBodyPartsData));
                            jokerChallengesTemplates = JSON.parse(JSON.stringify(defaultJokerChallengesTemplates));
                            editableActions = JSON.parse(JSON.stringify(actionsData));
                            editableBodyParts = JSON.parse(JSON.stringify(bodyPartsData));
                            editableJokerChallenges = JSON.parse(JSON.stringify(jokerChallengesTemplates));
                            renderUI();
                        }
                    }
                });

            } catch (error) {
                console.error("DEBUG: Firebase initialization error (outer catch block):", error);
                showMessageModal("Erreur d'initialisation Firebase : " + error.message, 'error');
                // Fallback to default data if Firebase init fails completely
                actionsData = JSON.parse(JSON.stringify(defaultActionsData));
                bodyPartsData = JSON.parse(JSON.stringify(defaultBodyPartsData));
                jokerChallengesTemplates = JSON.parse(JSON.stringify(defaultJokerChallengesTemplates));
                editableActions = JSON.parse(JSON.stringify(actionsData));
                editableBodyParts = JSON.parse(JSON.stringify(bodyPartsData));
                editableJokerChallenges = JSON.parse(JSON.stringify(jokerChallengesTemplates));
                renderUI();
            }
        }

        // New function to load public game data (actions, body parts, joker challenges)
        async function loadPublicGameData() {
            if (!db) {
                console.warn("DEBUG: Firestore DB not ready for public data loading.");
                return;
            }

            // Chemins standardis√©s pour les donn√©es publiques
            const actionsDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'gameData', 'actions');
            const bodyPartsDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'gameData', 'bodyParts');
            const jokerChallengesDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'gameData', 'jokerChallenges');

            let actionsLoaded = false;
            let bodyPartsLoaded = false;
            let jokerChallengesLoaded = false;

            const checkAllPublicLoaded = () => {
                if (actionsLoaded && bodyPartsLoaded && jokerChallengesLoaded) {
                    console.log("DEBUG: All public game data loaded.");
                    // No renderUI here, it's called after user data loads in onAuthStateChanged
                }
            };

            onSnapshot(actionsDocRef, async (docSnap) => {
                console.log("DEBUG: onSnapshot for actions fired. Doc exists:", docSnap.exists());
                if (docSnap.exists()) {
                    actionsData = docSnap.data();
                    console.log("DEBUG: Actions data loaded from Firestore:", actionsData);
                } else {
                    console.log("DEBUG: No actions data found in Firestore, setting default and uploading.");
                    actionsData = JSON.parse(JSON.stringify(defaultActionsData));
                    await setDoc(actionsDocRef, actionsData); // Set defaults and upload
                }
                editableActions = JSON.parse(JSON.stringify(actionsData));
                console.log("DEBUG: editableActions updated:", editableActions);
                actionsLoaded = true;
                checkAllPublicLoaded();
            }, (error) => {
                console.error("DEBUG: Error fetching actions data:", error);
                showMessageModal("Erreur lors du chargement des actions : " + error.message, 'error');
                actionsData = JSON.parse(JSON.stringify(defaultActionsData)); // Fallback to default
                editableActions = JSON.parse(JSON.stringify(actionsData));
                actionsLoaded = true;
                checkAllPublicLoaded();
            });

            onSnapshot(bodyPartsDocRef, async (docSnap) => {
                console.log("DEBUG: onSnapshot for body parts fired. Doc exists:", docSnap.exists());
                if (docSnap.exists()) {
                    bodyPartsData = docSnap.data();
                    console.log("DEBUG: Body parts data loaded from Firestore:", bodyPartsData);
                } else {
                    console.log("DEBUG: No body parts data found in Firestore, setting default and uploading.");
                    bodyPartsData = JSON.parse(JSON.stringify(defaultBodyPartsData));
                    await setDoc(bodyPartsDocRef, bodyPartsData);
                }
                editableBodyParts = JSON.parse(JSON.stringify(bodyPartsData));
                console.log("DEBUG: editableBodyParts updated:", editableBodyParts);
                bodyPartsLoaded = true;
                checkAllPublicLoaded();
            }, (error) => {
                console.error("DEBUG: Error fetching body parts data:", error);
                showMessageModal("Erreur lors du chargement des zones du corps : " + error.message, 'error');
                bodyPartsData = JSON.parse(JSON.stringify(defaultBodyPartsData)); // Fallback to default
                editableBodyParts = JSON.parse(JSON.stringify(bodyPartsData));
                bodyPartsLoaded = true;
                checkAllPublicLoaded();
            });

            onSnapshot(jokerChallengesDocRef, async (docSnap) => {
                console.log("DEBUG: onSnapshot for joker challenges fired. Doc exists:", docSnap.exists());
                if (docSnap.exists()) {
                    jokerChallengesTemplates = docSnap.data();
                    console.log("DEBUG: Joker challenges data loaded from Firestore:", jokerChallengesTemplates);
                } else {
                    console.log("DEBUG: No joker challenges data found in Firestore, setting default and uploading.");
                    jokerChallengesTemplates = JSON.parse(JSON.stringify(defaultJokerChallengesTemplates));
                    await setDoc(jokerChallengesDocRef, jokerChallengesTemplates);
                }
                editableJokerChallenges = JSON.parse(JSON.stringify(jokerChallengesTemplates));
                console.log("DEBUG: editableJokerChallenges updated:", editableJokerChallenges);
                jokerChallengesLoaded = true;
                checkAllPublicLoaded();
            }, (error) => {
                console.error("DEBUG: Error fetching joker challenges data:", error);
                showMessageModal("Erreur lors du chargement des d√©fis Joker : " + error.message, 'error');
                jokerChallengesTemplates = JSON.parse(JSON.stringify(defaultJokerChallengesTemplates)); // Fallback to default
                editableJokerChallenges = JSON.parse(JSON.stringify(jokerChallengesTemplates));
                jokerChallengesLoaded = true;
                checkAllPublicLoaded();
            });
        }


        // --- Gestion des √©v√©nements ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DEBUG: DOMContentLoaded fired.");

            // Explicitly show the instructions modal first.
            // This ensures it's visible immediately, regardless of async Firebase loading.
            showModal(instructionsModal);

            initializeFirebaseAndLoadData(); // Start Firebase init and data loading

            // Instructions Modal
            closeInstructionsBtn.onclick = () => {
                showInstructions = false;
                // startAudioContext(); // Supprim√©
                hideModal(instructionsModal); // Explicitly hide the modal here
                renderUI(); // Then render the rest of the UI
            };

            // Error Modal
            closeErrorModalBtn.onclick = () => {
                hideModal(errorModal);
            };

            // Level Up Modal
            closeLevelUpModalBtn.onclick = () => {
                showLevelUpModal = false;
                hideModal(levelUpModal);
                renderUI();
            };

            // Admin Mode
            adminModeBtn.onclick = () => {
                isAdminMode = !isAdminMode;
                if (!isAdminMode) {
                    adminPassword = '';
                    adminPasswordInput.value = ''; // Clear password input on exit
                    hideModal(adminModal); // Explicitly hide admin modal
                }
                renderUI();
            };

            validateAdminPasswordBtn.onclick = () => {
                if (adminPasswordInput.value === ADMIN_SECRET_PASSWORD) {
                    showMessageModal('Acc√®s Admin accord√© !', 'success', true);
                    adminPassword = ADMIN_SECRET_PASSWORD;
                } else {
                    showMessageModal('Mot de passe incorrect !', 'error');
                    adminPasswordInput.value = '';
                }
                renderUI();
            };

            closeAdminModalBtn.onclick = () => {
                isAdminMode = false;
                adminPassword = '';
                adminPasswordInput.value = '';
                hideModal(adminModal);
                renderUI();
            };

            // Player Management
            addPlayerBtn.onclick = addPlayer;
            newPlayerNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addPlayer();
            });
            addTenPlayersBtn.onclick = addTenPlayersAutomatically;

            // Level Select
            levelSelect.onchange = handleLevelChange;

            // Game Controls
            spinWheelBtn.onclick = spinWheel;
            startCountdownBtn.onclick = startCountdown;
            changeJokerChallengeBtn.onclick = changeJokerChallenge;

            // Admin Save Buttons
            saveActionsDataBtn.onclick = saveActionsData;
            saveBodyPartsDataBtn.onclick = saveBodyPartsData;
            saveJokerChallengesDataBtn.onclick = saveJokerChallengesData;

            // New: Add click listeners for individual reels
            player1ReelContainer.onclick = () => reSpinReel('player1');
            actionReelContainer.onclick = () => reSpinReel('action');
            bodyPartReelContainer.onclick = () => reSpinReel('bodyPart');
            player2ReelContainer.onclick = () => reSpinReel('player2');
            countdownReelContainer.onclick = () => reSpinReel('countdown');
        });

        // Background gradients
        const backgroundGradients = [
            'from-blue-100 via-blue-200 to-purple-200',
            'from-purple-200 via-pink-200 to-rose-300',
            'from-pink-300 via-purple-300 to-indigo-400',
            'from-red-400 via-pink-500 to-purple-500',
            'from-red-600 via-purple-700 to-pink-700',
            'from-purple-700 via-red-800 to-pink-800'
        ];

    </script>
</body>
</html>
